{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Erlang LS","text":"<p>Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice.</p> <p>A brilliant intuition, the Language Server Protocol, also known as LSP, changes the rules of the game. A real blessing for the Erlang community.</p> <p>Erlang LS is a language server providing language features for the Erlang programming language. The server works with Emacs, VSCode, Sublime Text 3, Vim and probably many more text editors and IDE which adhere to the LSP protocol.</p> <p>These pages contain all the information needed to configure your favourite text editor or IDE and to work with Erlang LS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected.</p>"},{"location":"#get-in-touch","title":"Get in touch","text":"<p>If you have any questions about the project, feel free to open a new issue on GitHub. You can also join the #erlang-ls channel in the Erlanger Slack if you would like to get involved or if you prefer a more informal mean of communication. All contributions are welcome, be them in the form of a bug report, a question, feedback, or code.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#the-erlang_lsconfig-file","title":"The <code>erlang_ls.config</code> file","text":"<p>It is possible to customize the behaviour of the <code>erlang_ls</code> server via a configuration file, named <code>erlang_ls.config</code>. The <code>erlang_ls.config</code> file should be placed in the root directory of a given project to store the configuration for that project.</p> <p>A sample <code>erlang_ls.config</code> file would look like the following:</p> <pre><code>otp_path: \"/path/to/otp/lib/erlang\"\ndeps_dirs:\n  - \"lib/*\"\ndiagnostics:\n  enabled:\n    - crossref\n  disabled:\n    - dialyzer\ninclude_dirs:\n  - \"include\"\n  - \"_build/default/lib\"\nlenses:\n  enabled:\n    - ct-run-test\n  disabled:\n    - show-behaviour-usages\nmacros:\n  - name: DEFINED_WITH_VALUE\n    value: 42\n  - name: DEFINED_WITHOUT_VALUE\ncode_reload:\n  node: node@example\nproviders:\n  enabled:\n    - signature-help\n</code></pre> <p>The file format is <code>yaml</code>.</p> <p>The following customizations are possible:</p>    Parameter Description     apps_dirs List of directories containing project applications. It supports wildcards.   code_reload Whether or not an rpc call should be made to a remote node to compile and reload a module   deps_dirs List of directories containing dependencies. It supports wildcards.   diagnostics Customize the list of active diagnostics. See below for a list of available diagnostics.   include_dirs List of directories provided to the compiler as include dirs. It supports wildcards.   incremental_sync Whether or not to support incremental synchronization of text changes in the client. Enabled by default.   lenses Customize the list of active code lenses   macros List of cusom macros to be passed to the compiler, expressed as a name/value pair. If the value is omitted or is invalid, 'true' is used.   otp_apps_exclude List of OTP applications that will not be indexed (default: megaco, diameter, snmp, wx)   otp_path Path to the OTP installation   plt_path Path to the dialyzer PLT file. When none is provided the dialyzer diagnostics will not be available.   code_path_extra_dirs List of wildcard Paths erlang_ls will add with code:add_path/1   elvis_config_path Path to the elvis.config file. Defaults to ROOT_DIR/elvis.config   exclude_unused_includes List of includes files that are excluded from the <code>UnusedIncludes</code> warnings.   compiler_telemetry_enabled When enabled, send <code>telemetry/event</code> LSP messages containing the <code>code</code> field of any diagnostics present in a file. Defaults to false.   providers Which LSP providers should be advertised to clients"},{"location":"configuration/#diagnostics","title":"Diagnostics","text":"<p>When a file is open or saved, a list of diagnostics are run in the background, reporting eventual issues with the code base to the editor. The following diagnostics are available:</p>    Diagnostic Name Purpose Default     bound_var_in_pattern Report already bound variables in patterns (inspired by the pinning operator) enabled   compiler Report in-line warnings and errors from the Erlang compiler enabled   crossref Use information from the Erlang LS Database to find out about undefined functions disabled   dialyzer Use the dialyzer static analysis tool to find discrepancies in your code enabled   elvis Use elvis to review the style of your Erlang code enabled   unused_includes Warn about header files which are included but not utilized enabled   unused_macros Warn about macros which are defined but not utilized enabled    <p>It is possible to customize diagnostics for a specific project. For example:</p> <pre><code>diagnostics:\n  disabled:\n    - dialyzer\n  enabled:\n    - crossref\n</code></pre>"},{"location":"configuration/#automatic-code-reloading","title":"Automatic Code Reloading","text":"<p>The <code>code_reload</code> takes the following options:</p>    Parameter Description     node The node to be called for code reloading. Example erlang_ls@hostname"},{"location":"configuration/#code-lenses","title":"Code Lenses","text":"<p>Code Lenses are also available in Erlang LS. The following lenses are available in Erlang LS:</p>    Code Lens Name Purpose     ct-run-test Display a run button next to a Common Test testcase   function-references Show the number of references to a function   server-info Display some Erlang LS server information on the top of each module. For debug only.   show-behaviour-usages Show the number of modules implementing a behaviour   suggest-spec Use information from dialyzer to suggest a spec    <p>The following lenses are enabled by default:</p> <ul> <li>show-behaviour-usages</li> </ul> <p>It is possible to customize lenses for a specific project. For example:</p> <pre><code>lenses:\n  enabled:\n    - ct-run-test\n  disabled:\n    - show-behaviour-usages\n</code></pre>"},{"location":"configuration/#providers","title":"Providers","text":"<p>Which LSP Providers are advertised to the client may be configured. The following providers are available in Erlang LS:</p>    Provider Name Purpose Default     text-document-sync Synchronize the document state between client and server enabled   hover Provide docmuentation for the symbol under the cursor on hover enabled   completion Provide auto-completion candidates for partial symbols enabled   signature-help Provide documentation for the current function and parameters on-type disabled   definition Jump to the definition of a given symbol enabled   references Jump to references of a given symbol enabled   document-highlight Highlight all other references to a symbol in scope enabled   document-symbol Provide all positions of a symbol in the current document enabled   workspace-symbol Provide all positions of a symbol across the workspace enabled   code-action Find commands to execute enabled   execute-command Execute code-action commands, returning edits to the client enabled   document-formatting Format an entire document enabled   document-range-formatting Format a given range of a document disabled   document-on-type-formatting Format parts of a document while typing disabled   folding-range Return all folding ranges in a document enabled   implementation Jump to the implementations of a callback enabled   code-lens Provide reference text and a command for position of interest in a document enabled   rename Rename a symbol across a workspace enabled   call-hierarchy Find the incoming and outgoing calls of the given position enabled   semantic-token Add additional highlighting information based on context-specific information enabled    <p>Providers may be customized with the <code>providers</code> key. For example:</p> <pre><code>providers:\n  enabled:\n    - signature-help\n  disabled:\n    - hover\n</code></pre>"},{"location":"configuration/#global-configuration","title":"Global Configuration","text":"<p>It is also possible to store a system-wide default configuration in an <code>erlang_ls.config</code> file located in the User Config directory. The exact location of the User Config directory depends on the operating system used and it can be identified by executing the following command on an Erlang shell:</p> <pre><code>&gt; filename:basedir(user_config, \"erlang_ls\").\n</code></pre> <p>Normally, the location of the User Config directory is:</p>    Operating System User Config Directory     Linux /home/USER/.config/erlang_ls   OS X /Users/USER/Library/Application\\ Support/erlang_ls   Windows c:/Users/USER/AppData/Local/erlang_ls    <p>Thus on Linux, for example, the full path to the default configuation file would be <code>/home/USER/.config/erlang_ls/erlang_ls.config</code></p>"},{"location":"configuration/#common-configurations","title":"Common configurations","text":"<p>Many Erlang repositories follow the same structure. We include common Erlang LS configurations in this section, for easy reuse.</p>"},{"location":"configuration/#rebar3-project","title":"<code>rebar3</code> project","text":"<p>The following configuration can be used for most rebar3 based projects.</p> <pre><code>apps_dirs:\n  - \"_build/default/lib/*\"\ninclude_dirs:\n  - \"_build/default/lib/*/include\"\n  - \"include\"\n</code></pre>"},{"location":"configuration/#rebar3-umbrella-project","title":"<code>rebar3</code> umbrella project","text":"<p>If your <code>rebar3</code> project includes multiple application (e.g. in an <code>apps</code> folder), you may want to adapt your Erlang LS configuration as follows.</p> <pre><code>apps_dirs:\n  - \"apps/*\"\ndeps_dirs:\n  - \"_build/default/lib/*\"\ninclude_dirs:\n  - \"apps\"\n  - \"apps/*/include\"\n  - \"_build/default/lib/\"\n  - \"_build/default/lib/*/include\"\n</code></pre>"},{"location":"configuration/#the-erlangotp-repository","title":"The <code>erlang/otp</code> repository","text":"<p>To be able to use the major Erlang LS features with the erlang/otp repository, the following minimal configuration should suffice.</p> <pre><code>otp_path: \"/path/to/otp\"\napps_dirs:\n  - \"lib/*\"\ninclude_dirs:\n  - \"lib\"\n  - \"lib/*/include\"\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#breadcrumbs","title":"Breadcrumbs","text":"<p>Breadcrumbs display a list of links to the current element and its ancestors in the top part of the page.</p>  VS Code <p>Breadcrumbs can be enabled or disabled via:</p>  <p>Settings &gt; Workbench &gt; Breadcrumbs</p>  <p>The settings section contains a number of additional preferences to tweak what to display exactly (e.g. icons, symbols, complete path to the file, etc).</p>  Emacs <p>Breadcrumbs are provided by the lsp-mode package. To enable breadcrumbs:</p> <pre><code>(setq lsp-headerline-breadcrumb-mode t)\n</code></pre> <p>You can also customize what to display in the breadcrumbs by customizing the <code>lsp-headerline-breadcrumb-segments</code> variable. For more information please refer to the official lsp-mode documentation.</p>"},{"location":"features/#code-completion","title":"Code Completion","text":"<p>Get context-aware code completions for function names, macros, records, variable names and more.</p>"},{"location":"features/#go-to-definition","title":"Go To Definition","text":"<p>Navigate to the definition of a function, macro, record or type.</p>"},{"location":"features/#go-to-implementation-for-otp-behaviours","title":"Go To Implementation for OTP Behaviours","text":"<p>Hovering a <code>gen_server:start_link</code> call? Jump to the respective <code>init</code> function with a single keystroke.</p>"},{"location":"features/#signature-suggestions","title":"Signature Suggestions","text":"<p>Never remember the order of the <code>lists:keytake/3</code> arguments? You are not alone. We got you covered.</p>"},{"location":"features/#compiler-diagnostics","title":"Compiler Diagnostics","text":"<p>Display warnings and errors from the compiler. Inline.</p>"},{"location":"features/#dialyzer-diagnostics","title":"Dialyzer Diagnostics","text":"<p>It has never been so easy to make Dialyzer happy.</p>"},{"location":"features/#elvis-diagnostics","title":"Elvis Diagnostics","text":"<p>Display Elvis style suggestions inline. No more nit-picking comments from colleagues!</p>"},{"location":"features/#edoc","title":"Edoc","text":"<p>Hover a local or remote function to see its <code>edoc</code>. You will miss this feature so much when edocs are not available that you will start writing them!</p>"},{"location":"features/#navigation-for-included-files","title":"Navigation for Included Files","text":"<p>Navigate to included files with a single click.</p>"},{"location":"features/#findpeek-references","title":"Find/Peek References","text":"<p>Who is calling this function? Figure it out without leaving the current context.</p>"},{"location":"features/#outline","title":"Outline","text":"<p>Get a nice outline of your module on the side and jump between functions.</p>"},{"location":"features/#workspace-symbols","title":"Workspace Symbols","text":"<p>Jump to the module you're looking for, in no time.</p>"},{"location":"features/#folding","title":"Folding","text":"<p>Focus on what's important, fold the rest.</p>"},{"location":"features/#snippets","title":"Snippets","text":"<p>Quickly insert parametrized, reusable pieces of code.</p>"},{"location":"features/#suggest-type-specs","title":"Suggest Type Specs","text":"<p>Annotate your Erlang programs with type information.</p>"},{"location":"features/#call-hierarchy","title":"Call Hierarchy","text":"<p>The Call Hierarchy feature lets you explore callers of a given function (known as incoming calls), as well as show which functions are called by a given function (known as outgoing calls).</p> <p>For an overview of what Call Hierarchy may look like, have a look to this video.</p> VS Code  <p>To display the Call Hierarchy panel, right-click on the name of a function and select Show Call Hierarchy. You can use the newly opened panel to navigate through the hierarchy of calls.</p> <p>To switch between incoming calls and outgoing calls simply use the phone icon on the top-right corner of the panel.</p>  Emacs  <p>The feature is provided by the lsp-treemacs package.</p> <p>To show the incoming calls hierarchy:</p> <pre><code>M-x lsp-treemacs-call-hierarchy\n</code></pre> <p>To show the outgoing calls hierarchy:</p> <pre><code>C-u M-x lsp-treemacs-call-hierarchy\n</code></pre> <p>For more information please refer to the official lsp-treemacs documentation.</p>"},{"location":"features/#code-actions","title":"Code Actions","text":"<p>Code Actions are a mechanism providing the user with possible corrective actions right next to an error or warning. If actions are available, a light bulb or similar icon appears next to the error or warning. When the user clicks the light bulb (or hits a shortcut), a list of available code actions is presented.</p> <p>Currently Erlang LS support code actions for:</p> <ul> <li>Exporting unused functions</li> <li>Prepending an underscore (<code>_</code>) to an unused variable</li> <li>Correct a mistyped name for an unbound variable</li> <li>Fix a module name to match the corresponding filename</li> </ul>"},{"location":"papers/","title":"Papers","text":"<p>A list of academic papers mentioning Erlang LS follows:</p> <ul> <li>B.Benavides, L.Castro, 2021 -  Detecting Oxbow Code in Erlang Codebases with the Highest Degree of Certainty - Proceedings of the 20th ACM SIGPLAN International Workshop on Erlang (Erlang \u201921).</li> </ul>"},{"location":"talks/","title":"Talks","text":""},{"location":"talks/#boost-your-productivity-with-the-erlang-language-server","title":"Boost your Productivity with the Erlang Language Server","text":"<p>2020-09-11 Code BEAM Stockholm (Virtual)</p>  <p>Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice.</p> <p>A brilliant intuition, the \"Language Server Protocol\" (LSP), changes the rules of the game. A real blessing for the Erlang community.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#attaching-to-the-language-server-via-a-remote-shell","title":"Attaching to the Language Server via a Remote Shell","text":"<p>Once an instance of the server is running, find the name of the node in the logs or by running <code>epmd -names</code>. It will look something like:</p> <pre><code>$ epmd -names\nepmd: up and running on port 4369 with data:\nname erlang_ls_projectname_62880311918 at port 50819\n</code></pre> <p>And you can connect to it via:</p> <pre><code>$ erl -sname debug -remsh erlang_ls_projectname_62880311918@`HOSTNAME`\n</code></pre> <p>If you see this error like this:</p> <pre><code>*** ERROR: Shell process terminated! (^G to start new job) ***\n=ERROR REPORT==== 5-Jun-2020::15:53:07.270087 ===\n** System NOT running to use fully qualified hostnames **\n** Hostname Host-Name-Here.local is illegal **\n</code></pre> <p>Then try running the command without the <code>@HOSTNAME</code> at the end, like so:</p> <pre><code>$ erl -sname debug -remsh erlang_ls_projectname_62880311918\n</code></pre> <p>The redbug application is included in the escript, so feel free to use it.</p>"},{"location":"troubleshooting/#logging","title":"Logging","text":"<p>Logs are written to your platform's log directory (i.e. the return value from <code>filename:basedir(user_log, \"erlang_ls\").</code>), in a file named <code>server.log</code>. For example on a Mac, the default location is <code>/Users/USERNAME/Library/Logs/erlang_ls/PROJECTDIR/server.log</code>, where USERNAME and PROJECTDIR are your operating system's user account name and the project folder that logs were generated for, respectively.</p> <p>It's possible to customize the logging directory by using the <code>--log-dir</code> option when starting the server.</p> <p>It's also possible to specify the verbosity of the logs by using the <code>--log-level</code> option. In addition to the <code>notice</code>, <code>debug</code>, <code>info</code>, <code>warning</code> and <code>error</code> levels, syslog style loglevel comparison flags can also be used.</p>"},{"location":"articles/otp-23-bring-docs/","title":"OTP 23 Brings Docs to the Shell, Erlang LS brings them to you!","text":"<p>You may have heard that Erlang/OTP 23 introduces a couple of new functions that can be used for displaying documentation for modules, functions and types in the Erlang shell:</p> <pre><code>1&gt; h(lists).\n\n   lists\n\n  This module contains functions for list processing.\n\n  Unless otherwise stated, all functions assume that position\n  numbering starts at 1. That is, the first element of a list is at\n  position 1.\n\n  Two terms T1 and T2 compare equal if T1\u00a0==\u00a0T2 evaluates to\n  true. They match if T1\u00a0=:=\u00a0T2 evaluates to true.\n\n  Whenever an ordering function F is expected as argument, it is\n  assumed that the following properties hold of F for all x, y,\n  and z:\n\n   \u2022 If x F y and y F x, then x = y (F is antisymmetric).\n\n   \u2022 If x F y and y F z, then x F z (F is transitive).\n\n   \u2022 x F y or y F x (F is total).\n\n  An example of a typical ordering function is less than or equal\nmore (y/n)? (y)\n</code></pre> <p>This is an amazing improvement, but as developers we often spend a good portion of our time in our IDE of choice, be it VSCode, Emacs, Vim or anything else. Wouldn't it be even more awesome if those pieces of documentation were closer to us in the IDE? It turns out this is something trivial to do.</p> <p>These pieces of documentation are stored as chunks using the format specified in the EEP-48 Erlang Enhancement Proposal and now implemented in OTP 23. Erlang LS already supports chunks, so the documentation for modules, functions and types is now available on hover when using OTP 23. This is how they look in Emacs:</p>  <p>To get them, ensure you build your Erlang/OTP distribution with support for Doc Chunks. If you are using kerl, this is as simple as:</p> <pre><code>KERL_BUILD_DOCS=yes KERL_DOC_TARGETS=chunks kerl build 23.0.1 23.0.1\nKERL_BUILD_DOCS=yes kerl install 23.0.1 /your/favourite/path/to/23.0.1\n</code></pre> <p>Enjoy!</p>"},{"location":"articles/snippets-are-here/","title":"Snippets are here","text":"<p>Snippets are a convenient way to insert portions of code without having to write them from scratch or to copy them from an external source every single time.</p>  <p>To start using snippets, ensure you have the latest version of Erlang LS. Then, simply start typing snippet. A dropdown with all available snippets will appear, so you can select one.</p>   <p>A few built-in snippets are available, ranging from a <code>try catch</code> construct to a <code>receive after</code> statement, from a <code>record</code> attribute to <code>edoc</code> blocks.</p> <p>Snippets contain placeholders, which can be used for easier navigation via the <code>TAB</code> key. They also have the concept of a variable, which gets expanded automatically when the snippet is selected. The syntax for snippets is described in detail here.</p> <p>Contributing snippets is trivial and does not require coding. Built-in snippets are stored in the Erlang LS priv directory.</p> <p>It is also possible to add custom snippets by dropping them into:</p> <pre><code>~/.config/erlang_ls/snippets\n</code></pre> <p>This mechanism allows your organization to customize snippets, so they match specific coding styles and conventions. A custom snippet which has the same name as built-in one will take precedence, so the former will override the latter in the snippets dropdown.</p> <p>Enjoy!</p>"},{"location":"articles/suggest-type-specs/","title":"Suggesting Type Specs","text":"<p>Erlang is a strict, dynamically typed, functional programming language. When implementing an Erlang function, it is not required to include any explicit information about the types of the input parameters, nor of the return value of the function. While this can sometimes be seen as convenient, in the sense that it allows fast prototyping of a function, it has the heavy drawback that type errors can occur at runtime, when it is too late. Lack of type information can also make it harder to understand the purpose of a function, given its signature.</p> <p>In the Erlang ecosystem, a tool named dialyzer exists to help the programmer to identify software discrepancies such as type errors via a static analysis.</p> <p>While Dialyzer works by inferring type information using a technique based on success typings, it is possible to explicitly annotate an Erlang function with type information. Adding type specifications to a function is particularly useful for the programmer when reading and reasoning about code, since they give an overview of the function contract.</p> <p>Given the function <code>sum/2</code> which computes the sum of two numbers:</p> <pre><code>sum(A, B) -&gt;\n  A + B.\n</code></pre> <p>We can annotate it with type specifications:</p> <pre><code>-spec sum(number(), number()) -&gt; number().\nsum(A, B) -&gt;\n  A + B.\n</code></pre> <p>For more information about type specifications and their syntax, please refer to the official reference manual.</p> <p>Type specifications can often be programmatically inferred. If we look again at the <code>sum/2</code> function above, we can see that the two input values for the function (<code>A</code> and <code>B</code>) are passed straight away to the <code>+</code> operator. That implies that, for the <code>sum/2</code> function not to fail, both <code>A</code> and <code>B</code> (and the return value of the function itself!) must be numbers. This is essentially how - well, in a very simplifyied way - a less known tool, named Typer, works under the hood to generate type specifications for functions which lack them.</p> <p>Erlang LS today leverages both Dialyzer and Typer to make it possible for the programmer to generate type specifications directly from the text editor.</p>  <p>First Time Setup</p> <p>To do its job, Dialyzer (and therefore Erlang LS) makes use of a Persistent Lookup Table (a.k.a. PLT). This table needs to be generated before you can use this feature in Erlang LS. Generating a PLT is a simple operation that can be achieved via:</p> <pre><code>dialyzer --build_plt --apps erts kernel stdlib\n</code></pre> <p>Where you can of course customize the provided list of applications. For more information about creating a PLT and how to later update it, please refer to the Dialyzer User Guide.</p>  <p>Whenever a function lacks type specifications, you will see a <code>Add spec</code> code lens next to the function definition. By clicking on the lens (or by using a keyboard shortcut), Erlang LS will attempt at suggesting type specifications for your function. This is what the procedure looks like in Emacs:</p>  <p>This feature is enabled by default in Erlang LS. Like for any other code lens, the feature can be disabled via the <code>erlang_ls.config</code> file, using the following configuration:</p> <pre><code>lenses:\n  disabled:\n    - suggest-spec\n</code></pre> <p>To make this possible, we had to fork the <code>typer</code> program from Erlang/OTP, mostly because the tool was designed as a separate Command Line utility and not to be invoked from Erlang code. This is something that should be easy to address in Erlang/OTP itself, avoiding the need of a fork in the future.</p> <p>There are a few other things to take into account when using this feature, most of which could be addressed in Typer itself:</p> <ul> <li>The function signatures do not include spaces after commas, making   linters complain</li> <li>When producing records, the output is extremely verbose (containing   types for all fields) and that should be simplified</li> <li>When user defined aliases exist for a given type, they should be   used (this can be tricky to implement)</li> </ul> <p>Finally, other tools such as Gradualizer could be considered and eventually integrated in Erlang LS.</p> <p>For now, I hope you enjoy!</p>"},{"location":"articles/tutorial-code-lenses/","title":"How To: Code Lenses","text":"<p>In our previous tutorial we learned how to implement a diagnostics backend for the Erlang Language Server. This time we will dig into the world of Code Lenses.</p>"},{"location":"articles/tutorial-code-lenses/#the-goal","title":"The Goal","text":"<p>Given an Erlang module containing a number of function defintions, we want to display the number of references to each function above its respective definition. Here is how the code lens will look like in VS Code.</p>  <p>At the end of this tutorial you will:</p> <ul> <li>Know what a code lens is</li> <li>Learn how to implement a code lens in Erlang LS</li> <li>Move a step closer to becoming an Erlang LS contributor</li> </ul> <p>Without further ado, let's start.</p>"},{"location":"articles/tutorial-code-lenses/#what-is-a-code-lens-anyway","title":"What is a Code Lens, anyway?","text":"<p>A Code Lens is defined by Wade Anderson as:</p>  <p>an actionable contextual information interspersed in your source code</p>  <p>That's a very fancy way to say that a code lens is an arbitrary piece of text which appears in the IDE, next to your code. The text often provides insights about a portion of the code, as in the example we just saw above.</p> <p>Code lenses can also be actionable. The user can activate a lens by clicking on it or by using a keyboard shortcut, to perform an action. The triggered action can be anything. Here is an Emacs code lens which allows the user to execute a given Common Test testcase:</p>  <p>Code lenses are contextual, meaning that they are aware of the surrounding context. In the above example, the Run test lens is aware of which specific testcase should be executed on click.</p> <p>Now that we understand what a code lens is, let's implement one in Erlang LS.</p>"},{"location":"articles/tutorial-code-lenses/#implementing-a-new-code-lens-backend","title":"Implementing a New Code Lens Backend","text":"<p>Erlang LS provides a framework to make development of code lenses as simple as possible. To create our new code lens, the first thing we need to do is to decide a name for it and to create a new Erlang module implementing the <code>els_code_lens</code> behaviour. Let's call the new code lens function_references.</p> <pre><code>-module(els_code_lens_function_references).\n-behaviour(els_code_lens).\n</code></pre> <p>The <code>els_code_lens</code> behaviour requires three callback functions to be implemented:</p> <pre><code>-callback is_default() -&gt; boolean().\n-callback pois(els_dt_document:item()) -&gt; [poi()].\n-callback command(els_dt_document:item(), poi(), state()) -&gt; els_command:command().\n</code></pre> <p>We will see in a second what each callback function is supposed to do. For now, let's add the following exports to our <code>els_code_lens_function_references</code> module:</p> <pre><code>-export([ is_default/0\n        , pois/1\n        , command/3\n        ]).\n</code></pre> <p>Now we can focus on each individual callback function.</p>"},{"location":"articles/tutorial-code-lenses/#the-is_default0-callback","title":"The <code>is_default/0</code> callback","text":"<p>The <code>is_default/0</code> callback is used to specify if the current backend should be enabled by default or not. In our case, we want the new backend to be enabled by default, so we say:</p> <pre><code>is_default() -&gt; true.\n</code></pre> <p>Should the end user decide to disable this backend, she can just add to her <code>erlang_ls.config</code> the following option:</p> <pre><code>lenses:\n  disabled:\n    function_references\n</code></pre>"},{"location":"articles/tutorial-code-lenses/#the-pois1-callback","title":"The <code>pois/1</code> callback","text":"<p>In Erlang LS jargon, POI stands for Point of Interest. The term refers to the interesting bits that are part of a code base. Points of Interest are indexed by Erlang LS and stored in an in-memory database. A POI could refer to a function definition, a macro definition, a record usage, you name it. Erlang LS provides a set of utilities that allow for easy search and manipulation of Points Of Interest.</p> <p>The <code>pois/1</code> function takes a single argument, the current document. Its return value is the list of POIs for which the lens should be activated for. In our case, we want our lens to be visible next to each function definition. Therefore, we write:</p> <pre><code>pois(Document) -&gt;\n  els_dt_document:pois(Document, [function]).\n</code></pre>"},{"location":"articles/tutorial-code-lenses/#the-command3-callback","title":"The <code>command/3</code> callback","text":"<p>The last mandatory callback we need to implement is the <code>command/3</code> one. The callback takes three arguments: the current Document, a specific POI and a State. For the sake of this tutorial, we will ignore the <code>State</code> and focus on the first two arguments only.</p>"},{"location":"articles/tutorial-code-lenses/#the-command","title":"The Command","text":"<p>The function needs to return a command. A command is an LSP data structure which contains:</p> <ul> <li>A title - the text which is rendered next to each selected POI</li> <li>A CommandId - an identifier for the command that gets executed on click</li> <li>The CommandArgs - the list of arguments to pass to the command</li> </ul> <p>Erlang LS provides an helper function to create such a data structure: the <code>els_command:make_command/3</code> function. Then, our <code>command/3</code> function will look something like this:</p> <pre><code>command(Document, POI, _State) -&gt;\n  Title = title(Document, POI),\n  CommandId = command_id(),\n  CommandArgs = command_args(),\n  els_command:make_command(Title, CommandId, CommandArgs).\n</code></pre> <p>We will now describe each paramater in detail and learn how to compute them, starting from the <code>Title</code>.</p>"},{"location":"articles/tutorial-code-lenses/#the-title","title":"The Title","text":"<p>The <code>Title</code> is the text that we want to present in the text editor, next to our Point of Interest (a.k.a. the POI). In our case, we want to display the following text:</p>  <p>Used [N] times</p>  <p>To be able to compute the number <code>N</code>, we need to know how many references to the current function are spread across our code base. We can therefore query the Erlang LS database via the <code>els_dt_references:find_by_id/2</code> helper function:</p> <pre><code>title(Document, POI) -&gt;\n\n  %% Extract the module name from the current document\n  #{uri := Uri} = Document,\n  M = els_uri:module(Uri),\n\n  %% Extract the function name and arity from the current POI\n  #{id := {F, A}} = POI,\n\n  %% Query the Erlang LS DB for references to the current function\n  {ok, References} = els_dt_references:find_by_id(function, {M, F, A}),\n\n  %% Calculate the number of references\n  N = length(References),\n\n  %% Format the title for the code lens\n  unicode:characters_to_binary(io_lib:format(\"Used ~p times\", [N])).\n</code></pre> <p>The <code>els_dt_references:find_by_id/2</code> function takes two arguments: the <code>Kind</code> of references we are looking for (<code>function</code> in our case) and the fully qualified <code>Id</code> of the current Point of Interest. For a function definition, the fully qualified identifier is a <code>{M, F, A}</code> tuple, representing the Module, the Function Name and the Arity of our function. As you can see above, we can extract the module <code>M</code> from the <code>Document</code> and the <code>F</code> and <code>A</code> from the current <code>POI</code>.</p>"},{"location":"articles/tutorial-code-lenses/#commandid-and-commandargs","title":"CommandId and CommandArgs","text":"<p>The <code>CommandId</code> is an arbitrary identifier for the command we want to run when the user clicks on our code lens. In our case, this action will be a no-op, but we still need to pick a name for our command. Let's call it <code>function-references</code>:</p> <pre><code>command_id() -&gt; &lt;&lt;\"function-references\"&gt;&gt;.\n</code></pre> <p>Since our command will be a no-op (we do not want anything to happen if the user clicks on the lens), our command will not require any arguments:</p> <pre><code>command_args() -&gt; [].\n</code></pre> <p>We are essentially done. Here is our full <code>els_code_lens_function_references</code> module, for completeness:</p> <pre><code>-module(els_code_lens_function_references).\n\n-behaviour(els_code_lens).\n-export([ is_default/0\n        , pois/1\n        , command/3\n        ]).\n\nis_default() -&gt;\n  true.\n\npois(Document) -&gt;\n  els_dt_document:pois(Document, [function]).\n\ncommand(Document, POI, _State) -&gt;\n  Title = title(Document, POI),\n  CommandId = command_id(),\n  CommandArgs = command_args(),\n  els_command:make_command(Title, CommandId, CommandArgs).\n\ntitle(Document, POI) -&gt;\n  #{uri := Uri} = Document,\n  M = els_uri:module(Uri),\n  #{id := {F, A}} = POI,\n  {ok, References} = els_dt_references:find_by_id(function, {M, F, A}),\n  N = length(References),\n  unicode:characters_to_binary(io_lib:format(\"Used ~p times\", [N])).\n\ncommand_id() -&gt;\n  &lt;&lt;\"function-references\"&gt;&gt;.\n\ncommand_args() -&gt;\n  [].\n</code></pre>"},{"location":"articles/tutorial-code-lenses/#registering-the-code-lens","title":"Registering the code lens","text":"<p>There is one more thing that we need to do before we can use our new shiny code lens: we need to tell Erlang LS that it exists. That can be achieved by adding our new code lens to the list of <code>available_lenses</code> in the <code>els_code_lens</code> module:</p> <pre><code>available_lenses() -&gt;\n  [ ...\n  , &lt;&lt;\"function-references\"&gt;&gt;\n  ].\n</code></pre> <p>That's all.</p>"},{"location":"articles/tutorial-code-lenses/#adding-tests","title":"Adding tests","text":"<p>Our code lens at this point should be functional, but we cannot be sure until we write a test for it!  Erlang LS provides a testing framework which can be used for this purpose. In this section we will assume that you have a bit of familiarity with the Erlang LS testing framework already. If you would like a more gentle introduction to testing in Erlang LS, please refer to the previous Diagnostics Tutorial.</p>"},{"location":"articles/tutorial-code-lenses/#creating-a-test-module","title":"Creating a test module","text":"<p>Let's create a test module named <code>code_lens_function_references</code> within the <code>code_navigation</code> test application:</p> <pre><code>$ cat apps/els_lsp/priv/code_navigation/src/code_lens_function_references.erl\n-module(code_lens_function_references).\n\n-export([ a/0 ]).\n\n-spec a() -&gt; ok.\na() -&gt;\n  b(),\n  c().\n\n-spec b() -&gt; ok.\nb() -&gt;\n  c().\n\n-spec c() -&gt; ok.\nc() -&gt;\n  ok.\n</code></pre>"},{"location":"articles/tutorial-code-lenses/#registering-the-new-testing-module","title":"Registering the new testing module","text":"<p>Simply open the <code>els_test_utils</code> module and add the new module to the list of sources. This will ensure the new module is properly indexed and some helper functions are available for it.</p> <pre><code>sources() -&gt;\n  [ ...\n  , code_lens_function_references\n  , ...\n  ].\n</code></pre>"},{"location":"articles/tutorial-code-lenses/#writing-a-testcase","title":"Writing a testcase","text":"<p>Let's then open the <code>els_code_lens_SUITE</code> module and add a testcase, where we check whether the new code lens works as expected in the new module.</p> <pre><code>function_references(Config) -&gt;\n  Uri = ?config(code_lens_function_references_uri, Config),\n  #{result := Result} = els_client:document_codelens(Uri),\n  Expected = [ lens(5, 0) # First lens on line 5, 0 references\n             , lens(10, 1) # Second lens on line 10, 1 reference\n             , lens(14, 2) # Third lens on line 14, 2 references\n             ],\n  ?assertEqual(Expected, Result),\n  ok.\n</code></pre> <p>In the above testcase, we are fetching the <code>Uri</code> of the newly added test module by leveraging the Erlang LS testing framework. We then use the <code>els_client</code> to invoke the <code>document_codelens</code> method for the given <code>Uri</code> and we finally ensure that we receive the expected list of code lenses. <code>lens/2</code> is an auxiliary function which constructs the data structure expected by the LSP protocol as follows:</p> <pre><code>lens(Line, Usages) -&gt;\n  Title = unicode:characters_to_binary(\n            io_lib:format(\"Used ~p times\", [Usages])),\n  #{ command =&gt;\n       #{ arguments =&gt; []\n        , command =&gt; els_command:with_prefix(&lt;&lt;\"function-references\"&gt;&gt;)\n        , title =&gt; Title\n        }\n   , data =&gt; []\n   , range =&gt;\n       #{ 'end' =&gt; #{character =&gt; 1, line =&gt; Line}\n        , start =&gt; #{character =&gt; 0, line =&gt; Line}\n        }\n   }.\n</code></pre> <p>Let's run the test and ensure it passes.</p> <pre><code>$ rebar3 ct --suite apps/els_lsp/test/els_code_lens_SUITE --case function_references --group tcp\n[...]\n===&gt; Running Common Test suites...\n%%% els_code_lens_SUITE: .\nAll 1 tests passed.\n</code></pre> <p>It looks like we are done here.</p>"},{"location":"articles/tutorial-code-lenses/#optional-callbacks","title":"Optional Callbacks","text":"<p>Even if they are not needed for this tutorial, it is worth mentioning that two more optional callback functions are available as part of the <code>els_code_lens</code> behaviour:</p> <pre><code>-callback init(els_dt_document:item()) -&gt; state().\n-callback precondition(els_dt_document:item()) -&gt; boolean().\n</code></pre> <p>Let's describe them for completeness.</p>"},{"location":"articles/tutorial-code-lenses/#the-init1-callback","title":"The <code>init/1</code> callback","text":"<p>The <code>init/1</code> callback allows us to perform some computation once per file and to pass around the computed values in the form a State to subsequent callback functions (remember the <code>State</code> argument which we ignored in the <code>command/3</code> callback?). This is used, for example, in the <code>suggest_spec</code> code lens to run <code>TypEr</code> once for each Erlang module and to still be able to display one lens for each function.</p>"},{"location":"articles/tutorial-code-lenses/#the-precondition1-callback","title":"The <code>precondition/1</code> callback","text":"<p>The <code>precondition/1</code> callback allows us to only enable a given lens for a specific type of documents. For example, the following implementation enables the <code>ct_run_test</code> lens only for Common Test suites, identified by the presence of an <code>include_lib</code> directive for the <code>ct.hrl</code> file:</p> <pre><code>precondition(Document) -&gt;\n  Includes = els_dt_document:pois(Document, [include_lib]),\n  case [POI || #{id := \"common_test/include/ct.hrl\"} = POI &lt;- Includes] of\n    [] -&gt;\n      false;\n    _ -&gt;\n      true\n  end.\n</code></pre>"},{"location":"articles/tutorial-code-lenses/#conclusion","title":"Conclusion","text":"<p>At this point you should be able to try out your new code lens. The above code lens is already available in Erlang LS. You can see the whole contribution at:</p> <p>https://github.com/erlang-ls/erlang_ls/pull/947</p> <p>I hope this tutorial helped you to get a better understanding about code lenses in general and how to implement one in Erlang LS. Looking forward to the wonderful lenses you will implement!</p>"},{"location":"articles/tutorial-debugger/","title":"How To: Use the Debugger","text":"<p>Erlang LS provides debugging functionalities via the Debug Adapter Protocol, in short DAP. Given the editor-agnostic nature of the protocol, debugging is available in all text editors and IDEs which support the DAP protocol. Here is what a debugging session looks like in Emacs:</p>  <p>The current underlying implementation is based on the Erlang interpreter which comes with Erlang/OTP. Incidentally, the official OTP Debugger is also powered by the same interpreter.</p> <p>In this tutorial we will bootstrap a sample project and see how we can debug our code using Erlang LS.</p>"},{"location":"articles/tutorial-debugger/#install-the-debugger","title":"Install the debugger","text":"<p>Debugging functionalities are provided in Erlang LS via a separate executable (an Erlang escript) named <code>els_dap</code>.</p> VS Code <p>The executable is bundled with the Erlang LS extension, so it does not require any additional installation steps. You can configure the Erlang LS extension to use a custom version of the debugger by specifying a different DAP Path:</p>  <p>Extension Settings &gt; DAP Path</p>   Emacs <p>If you are using Emacs, chances are that you are building Erlang LS from source. To produce the <code>els_dap</code> escript:</p> <pre><code>rebar3 as dap escriptize\n</code></pre> <p>Or simply:</p> <pre><code>make\n</code></pre> <p>You will then find the <code>els_dap</code> escript in:</p> <pre><code>_build/dap/bin/els_dap\n</code></pre> <p>Ensure the produced <code>els_dap</code> escript resides in a <code>PATH</code> known to Emacs.</p> <p>The official dap-mode package supports Erlang, so require both the package and the Erlang plugin:</p> <pre><code>(require 'dap-mode)\n(require 'dap-erlang)\n</code></pre> <p>You can refer to the official dap-mode documentation for more information on how to install and configure the <code>dap-mode</code> package and its plugins.</p>"},{"location":"articles/tutorial-debugger/#setup-a-sample-project","title":"Setup a sample project","text":"<p>To showcase the Erlang LS debugger we will use the Hello World example from the Cowboy webserver. Let's start by cloning the project:</p> <pre><code>git clone https://github.com/ninenines/cowboy.git\ncd cowboy/examples/hello_world\n</code></pre> <p>The project uses the erlang.mk build system and the relx release assembler. To be able to use the debugger with our sample project we will need to apply two small modifications to the project:</p> <ol> <li>Include the Erlang <code>debugger</code> as a dependency</li> <li>Tell erlang.mk to symlink the <code>hello_world</code> application in the release</li> </ol> <p>To add the <code>debugger</code> as a dependency, add the following line to the project's <code>Makefile</code> just before the <code>include ../../erlang.mk</code> line:</p> <pre><code>LOCAL_DEPS = debugger\n</code></pre> <p>To symlink the application, add the following line to the <code>relx.config</code> file:</p> <pre><code>{overrides, [{hello_world, \"../hello_world\"}]}.\n</code></pre> <p>We can now lunch our web server:</p> <pre><code>make run\n</code></pre> <p>The above should result in a new Erlang node running in the terminal, named <code>hello_world_example@[HOSTNAME]</code>.</p> <p>We should now be able to point our browser to <code>http://localhost:8080</code> to see our glorious Hello world! string.</p> <p>Let's keep the server running. Open a new terminal and proceed with the following steps.</p>"},{"location":"articles/tutorial-debugger/#create-a-launch-configuration","title":"Create a launch configuration","text":"<p>We need to tell the debugger how to connect to the running node. We will do so via a launch configuration.</p>  <p>About launch configurations</p> <p>Despite being a VS Code specific concept, launch configurations can now be used with multiple text editors and IDEs, including Emacs.</p>  VS Code <p>Navigate to the Run and Debug panel and click on Create a launch.json file link and select the Erlang OTP Debugger option.</p>  <p>This will create a file in <code>.vscode/launch.json</code>. Replace the content of the file with the following one:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Existing Erlang Node\",\n            \"type\": \"erlang\",\n            \"request\": \"attach\",\n            \"projectnode\": \"hello_world_example\",\n            \"cookie\": \"hello_world_example\",\n            \"timeout\": 300,\n            \"cwd\": \"${workspaceRoot}\"\n        }\n    ]\n}\n</code></pre>  Emacs <p>We need to create a file named <code>launch.json</code> in the top-level directory of the project. In our case, the file will reside in <code>cowboy/examples/hello_world/launch.json</code>:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Existing Erlang Node\",\n            \"type\": \"erlang\",\n            \"request\": \"attach\",\n            \"projectnode\": \"hello_world_example\",\n            \"cookie\": \"hello_world_example\",\n            \"timeout\": 300\n        }\n    ]\n}\n</code></pre>"},{"location":"articles/tutorial-debugger/#add-a-breakpoint","title":"Add a breakpoint","text":"VS Code <p>Access the <code>src/toppage_h.erl</code> file and add a breakpoint by clicking next to the line number corresponding to the first line of the <code>init/2</code> function body.</p>   Emacs <p>Navigate to the <code>src/toppage_h.erl</code>, move to the first line of the <code>init/2</code> function body and run:</p> <pre><code>M-x dap-breakpoint-add\n</code></pre>"},{"location":"articles/tutorial-debugger/#start-a-debugging-session","title":"Start a debugging session","text":"VS Code <p>Select the Run and Debug panel, select Existing Erlang Node from the dropdown and press the <code>play</code> button:</p>  <p>Open a new terminal and use the <code>curl</code> command to trigger our new breakpoint.</p> <pre><code>curl -i http://localhost:8080\n\nHTTP/1.1 200 OK\ncontent-length: 12\ncontent-type: text/plain\ndate: Fri, 09 Jul 2021 13:35:01 GMT\nserver: Cowboy\n\nHello world!\n</code></pre> <p>Execution will be paused on the breakpoint. You can then use the standard VS Code controls to control execution:</p>  <p>On the left hand side it is possible to explore the call stack and the variable bindings. For example, we can incrementally expand the bindings for the Cowboy input request and verify the value for the User Agent header:</p>  <p>The Debug Console at the bottom can be used as a REPL with the current variable bindings available:</p>  <p>The Watch List on the left can be used to track the value of a specific variable (for example, the <code>Opts</code> variable):</p>  <p>And the Debug Console to manipulate those values:</p>  <p>VS Code offers extensive debugging functionalities. For more information please refer to the official VS Code documentation.</p>  Emacs <p>Open the <code>src/toppage_h.erl</code> buffer and run:</p> <pre><code>M-x dap-debug\n</code></pre> <p>You will get prompted for a configuration template. Select Existing Erlang Node.</p> <p>Open a new terminal and use the <code>curl</code> command to trigger our new breakpoint.</p> <pre><code>curl -i http://localhost:8080\n\nHTTP/1.1 200 OK\ncontent-length: 12\ncontent-type: text/plain\ndate: Fri, 09 Jul 2021 13:35:01 GMT\nserver: Cowboy\n\nHello world!\n</code></pre> <p>Execution will be paused on the breakpoint. You can then use the standard Emacs controls to control execution:</p>  <p>On the right hand side it is possible to explore the call stack and the variable bindings. For example, we can incrementally expand the bindings for the Cowboy input request and verify the value for the User Agent header:</p>  <p>You can also open a REPL with the current variable bindings available:</p> <pre><code>M-x dap-eval\n</code></pre> <p>The <code>dap-mode</code> package offers extensive debugging functionalities. For more information please refer to the official documentation.</p>    <p>Debugging and concurrency</p> <p>Due to the nature of Erlang processes, debugging a concurrent system could be tricky. As an example, a breakpoint could cause an internal timeout to occur and cause a crash as a consequence. Therefore, Erlang processes may require to be properly isolated or protected during a step-by-step debugging session.</p>"},{"location":"articles/tutorial-debugger/#special-breakpoint-types","title":"Special Breakpoint Types","text":"<p>The DAP protocol describes a variety of breakpoint types which can be used in different situations:</p> <ul> <li>Conditional breakpoints</li> <li>Logpoints</li> <li>Hitpoints</li> </ul>"},{"location":"articles/tutorial-debugger/#conditional-breakpoints","title":"Conditional Breakpoints","text":"<p>Conditional breakpoints are only triggered whenever a given condition evaluates to <code>true</code>. For example, we may want execution to break only when the value of the Host header passed by the client contains the string pigeon:</p> VS Code <p>To setup a conditional breakpoint, right-click next to a line number and select the Add a conditional breakpoint... option. Add the following expression:</p> <pre><code>maps:get(&lt;&lt;\"host\"&gt;&gt;, maps:get(headers, Req0)) =:= &lt;&lt;\"pigeon\"&gt;&gt;\n</code></pre>   Emacs <p>To add a conditional breakpoint, move to an existing breakpoint, then run:</p> <pre><code>M-x dap-breakpoint-condition\n</code></pre> <p>And add the following expression:</p> <pre><code>maps:get(&lt;&lt;\"host\"&gt;&gt;, maps:get(headers, Req0)) =:= &lt;&lt;\"pigeon\"&gt;&gt;\n</code></pre>   <p>With the above conditional breakpoint set, the following request will not cause execution to break:</p> <pre><code>curl -i http://localhost:8080\n</code></pre> <p>But the following will:</p> <pre><code>curl -H \"Host: pigeon\" -i http://localhost:8080\n</code></pre>"},{"location":"articles/tutorial-debugger/#logpoints","title":"Logpoints","text":"<p>Logpoints are a special type of breakpoint which do not cause execution to break, but they result in a log message to be printed out in the Debug Console.</p> VS Code <p>To log the Host header on every request, right-click next to the line number and select the Add logpoint... option. Add the following Log Message:</p> <pre><code>maps:get(&lt;&lt;\"host\"&gt;&gt;, maps:get(headers, Req0))\n</code></pre> <p>Let's trigger a few requests with different (or default) host headers:</p> <pre><code>curl -i http://localhost:8080\ncurl -H \"Host: pigeon\" -i http://localhost:8080\n</code></pre> <p>We can then follow the logpoints in the debug console:</p>   Emacs <p>To log the Host header on every request, move to an existing breakpoint, then run:</p> <pre><code>M-x dap-breakpoint-log-message\n</code></pre> <p>Add the following Log Message:</p> <pre><code>maps:get(&lt;&lt;\"host\"&gt;&gt;, maps:get(headers, Req0))\n</code></pre> <p>Let's trigger a few requests with different (or default) host headers:</p> <pre><code>curl -i http://localhost:8080\ncurl -H \"Host: pigeon\" -i http://localhost:8080\n</code></pre> <p>To follow the logpoints, run:</p> <pre><code>M-x dap-go-to-output-buffer\n</code></pre>"},{"location":"articles/tutorial-debugger/#hitpoints","title":"Hitpoints","text":"<p>Hitpoints are a special kind of breakpoint which are triggered every Nth time.</p> VS Code <p>Select an existing breakpoint and choose the Hit Count option from the dropdown. Specify a number N. The respective breakpoint will be triggered every Nth time.</p>  Emacs <p>Navigate to an existing breakpoint. Run:</p> <pre><code>M-x dap-breakpoint-hit-condition\n</code></pre> <p>Specify a number N. The respective breakpoint will be triggered every Nth time.</p>"},{"location":"articles/tutorial-debugger/#troubleshooting","title":"Troubleshooting","text":"<p>If something does not work as expected, have a look to the Erlang LS DAP logs. They will most likely point you to the root cause of the issue. Logs are available at:</p> <pre><code>[USER_LOG_DIR]/[PROJECT_NAME]/dap_server.log\n</code></pre> <p>Where <code>[USER_LOG_DIR]</code> is the output of:</p> <pre><code>filename:basedir(user_log, \"els_dap\").\n</code></pre> <p>For example, on Mac OS, the DAP logs for the hello_world project will be in:</p> <pre><code>/Users/[USERNAME]/Library/Logs/els_dap/hello_world/dap_server.log\n</code></pre> <p>If the DAP logs do not help, feel free to reach out on GitHub or Slack.</p> <p>Happy debugging with Erlang LS!</p>"},{"location":"articles/tutorial-implementing-diagnostics/","title":"How To: Diagnostics","text":"<p>A couple of days ago, NextRoll announced rebar3_hank, a \"powerful but simple tool to detect dead code around your Erlang codebase (and kill it with fire!)\". In their original post the authors mentioned the overlap between rebar3_hank and some of the features provided by Erlang LS, such as detection of unused included files.</p> <p>Intrigued by the new tool, I decided to look deeper into it, to check whether rebar3_hank could be integrated with the diagnostics framework in Erlang LS, to avoid duplicated efforts within the Erlang Community.</p> <p>Both rebar3_hank and Erlang LS create diagnostics based on source code, but there are a few differences. For example, rebar3_hank acts on a project's code base as a whole, while Erlang LS operates on individual Erlang modules and their strict dependencies. Also, rebar3_hank is intended to be used as a CLI via a rebar3 plugin, while Erlang LS is a server which integrates with your IDE via the LSP protocol.</p> <p>It was immediately clear that an integration between both tools would require a certain degree of refactoring. The ideas of rebar3_hank were quite interesting, though, and most of them would be easily implementable in Erlang LS. So, I decided to port one of them, detection of unused macros, and to take this opportunity to explain the process of contributing a new diagnostics backend to Erlang LS.</p>  <p>If you always wanted to contribute to Erlang LS, but you didn't know where to start, this post is for you. Let's start.</p>"},{"location":"articles/tutorial-implementing-diagnostics/#the-goal","title":"The goal","text":"<p>Given an Erlang module, we would like to be notified with a warning if a macro is defined, but not used.</p>  <p>How can we make it happen?</p>"},{"location":"articles/tutorial-implementing-diagnostics/#adding-a-new-diagnostics-backend","title":"Adding a New Diagnostics Backend","text":"<p>The first thing we need to do is to define a new Erlang module which implements the <code>els_diagnostics</code> behaviour. By convention, all diagnostics modules are named <code>els_[BACKEND]_diagnostics.erl</code> where <code>[BACKEND]</code>, in our case, will be <code>unused_macros</code>. So, the final name of the module will be <code>els_unused_macros_diagnostics.erl</code>. Let's open a new text file and add the following:</p> <pre><code>-module(els_unused_macros_diagnostics).\n-behaviour(els_diagnostics).\n</code></pre> <p>The <code>els_diagnostics</code> behaviour requires three callback functions to be implemented:</p> <pre><code>-callback is_default() -&gt; boolean().\n-callback source()     -&gt; binary().\n-callback run(uri())   -&gt; [diagnostic()].\n</code></pre> <p>So let's add the following exports to the module. We will implement all functions in a second.</p> <pre><code>-export([ is_default/0\n        , source/0\n        , run/1\n        ]).\n</code></pre>"},{"location":"articles/tutorial-implementing-diagnostics/#the-is_default0-callback","title":"The <code>is_default/0</code> callback","text":"<p>The <code>is_default/0</code> callback is used to specify if the current backend should be enabled by default or not. In our case, we want the new backend to be enabled by default, so we say:</p> <pre><code>is_default() -&gt; true.\n</code></pre> <p>Should the end user decide to disable this backend, she can just add to her <code>erlang_ls.config</code> the following option:</p> <pre><code>diagnostics:\n  disabled:\n    unused_macros\n</code></pre>"},{"location":"articles/tutorial-implementing-diagnostics/#the-sources0-callback","title":"The <code>sources/0</code> callback","text":"<p>Let's now implement our second callback function, <code>source/0</code>. This function returns the human-friendly name for the backend, which is rendered by the IDE (see the <code>UnusedMacros</code> text in the above screenshot):</p> <pre><code>source() -&gt; &lt;&lt;\"UnusedMacros\"&gt;&gt;.\n</code></pre>"},{"location":"articles/tutorial-implementing-diagnostics/#the-run1-function","title":"The <code>run/1</code> function","text":"<p>The last callback function we need to implement is where the interesting stuff happens.</p> <p>The <code>run/1</code> function takes a single parameter, the <code>Uri</code> of the Erlang module for which diagnostics are run. By default, diagnostics are calculated OnOpen (when the module is firstly accessed in the IDE) and OnSave (whenever the module is saved from the IDE).</p> <p>The function returns a list of diagnostics for the module which will be rendered by the IDE, in a format specified by the LSP protocol. Diagnostics can be of four types:</p> <ul> <li>Hint</li> <li>Info</li> <li>Warning</li> <li>Error</li> </ul> <p>For the time being, let's return an empty list.</p> <pre><code>run(_Uri) -&gt; [].\n</code></pre>"},{"location":"articles/tutorial-implementing-diagnostics/#registering-the-backend","title":"Registering the backend","text":"<p>There's one more thing we need to do before we can use our backend in Erlang LS. We need to register it among the available backends. We can do this by adding an entry to the list of available diagnostics in the <code>els_diagnostics</code> module:</p> <pre><code>available_diagnostics() -&gt;\n  [ &lt;&lt;\"compiler\"&gt;&gt;\n  , &lt;&lt;\"crossref\"&gt;&gt;\n  , &lt;&lt;\"dialyzer\"&gt;&gt;\n  , &lt;&lt;\"elvis\"&gt;&gt;\n  , &lt;&lt;\"unused_includes\"&gt;&gt;\n  , &lt;&lt;\"unused_macros\"&gt;&gt; %% Here is our new shiny diagnostics backend!\n].\n</code></pre>"},{"location":"articles/tutorial-implementing-diagnostics/#using-a-test-driven-development-tdd-approach","title":"Using a Test-Driven-Development (TDD) approach","text":"<p>At this point, we could jump in and start implementing the body of our <code>run/1</code> function. Then, to try if things are working as expected, we could:</p> <ul> <li>Rebuild our version of Erlang LS as an escript</li> <li>Open a new file in our IDE</li> <li>Restart Erlang LS</li> <li>Add an unused macro to our new file</li> <li>Save the file</li> <li>Ensure that a warning is produced on save</li> <li>Check Erlang LS logs to see why things don't work the way we expect</li> <li>Rinse and repeat</li> </ul> <p>This approach may even work, but it would slow down our feedback loop drastically and it would make the whole experience of contributing to Erlang LS painful.</p> <p>Luckily, there's a better way: starting with a test case. After all, if we are planning to contribute our new backend, we will be required to add a test case anyway.</p> <p>How do we implement a test case for such a feature, though? That sounds like a lot of work and we don't know where to start. Here is where the Erlang LS testing framework comes into play.</p> <p>The first thing we need to do is to add a minimal example to the Erlang LS test application (which for historical reasons is named code_navigation and should be renamed). You can find it in the <code>priv</code> directory of the project.</p> <p>Our minimal example could look like this:</p> <pre><code>$ cat priv/code_navigation/src/diagnostics_unused_macros.erl\n-module(diagnostics_unused_macros).\n\n-export([main/0]).\n\n-define(USED_MACRO, used_macro).\n-define(UNUSED_MACRO, unused_macro).\n\nmain() -&gt;\n  ?USED_MACRO.\n</code></pre> <p>In the above code, we define two macros and we use only one of them. We therefore expect a warning on line 6 for the <code>UNUSED_MACRO</code>.</p> <p>We also need to register our minimal example into the Erlang LS testing framework. For that, we add a line to the list of <code>sources</code> in the <code>els_test_utils</code> module:</p> <pre><code>sources() -&gt;\n  [ ...\n  , diagnostics_unused_macros\n  , ...\n  ]\n</code></pre> <p>Now, we can focus on the actual test case. Since it's a diagnostics test, we can extend the already existing <code>els_diagnostics_SUITE</code> module. The test suite leverages the Common Test framework in Erlang/OTP, so please refer to the official documentation if you are not familiar with it.</p> <p>First, we export the new testcase, which we call <code>unused_macros</code>:</p> <pre><code>-export([ ...\n        , unused_macros/1\n        . ...\n        ])\n</code></pre> <p>Then, we can implement the body of our new testcase:</p> <pre><code>unused_macros(Config) -&gt;\n  Uri = ?config(diagnostics_unused_macros_uri, Config),\n  els_mock_diagnostics:subscribe(),\n  ok = els_client:did_save(Uri),\n  Diagnostics = els_mock_diagnostics:wait_until_complete(),\n  Expected = [ #{ message =&gt; &lt;&lt;\"Unused macro: UNUSED_MACRO\"&gt;&gt;\n                , range =&gt;\n                    #{ 'end' =&gt; #{ character =&gt; 20\n                                 , line =&gt; 5\n                                 }\n                     , start =&gt; #{ character =&gt; 8\n                                 , line =&gt; 5\n                                 }\n                     }\n                , severity =&gt; ?DIAGNOSTIC_WARNING\n                , source =&gt; &lt;&lt;\"UnusedMacros\"&gt;&gt;\n                }\n             ],\n  ?assertEqual(Expected, Diagnostics),\n  ok.\n</code></pre> <p>Lot of things are happening here, so let's go through the code together, starting from the beginning:</p> <pre><code>Uri = ?config(diagnostics_unused_macros_uri, Config),\n</code></pre> <p>Here we fetch the Uri of the Erlang module containing our minimal example from the Common Test <code>Config</code>. This feels a bit magic, since we never populated that variable anywhere. What's going on?</p> <p>Remember that we registered our new testing module in the <code>sources/1</code> function above? That caused the Erlang LS testing framework not just to index that file, but also to create a couple of handy variables which can be used when writing test cases. <code>[MODULE_NAME]_uri</code> is one of these variables. Another one is <code>[MODULE_NAME]_text</code>, which contains the actual source code of the module. But let's continue with our testcase for now:</p> <pre><code>els_mock_diagnostics:subscribe(),\n</code></pre> <p>Since we want to test a new diagnostics backend, we subscribe to the stream of <code>diagnostics</code>, so that we can intercept and validate them. Again, we use a utility function which the Erlang LS testing framework provides.</p> <pre><code>ok = els_client:did_save(Uri),\nDiagnostics = els_mock_diagnostics:wait_until_complete(),\n</code></pre> <p>We then simulate an IDE saving the file and wait until the diagnostics (which are calculated asynchronously) are completed.</p> <pre><code>Expected = [ #{ message =&gt; &lt;&lt;\"Unused macro: UNUSED_MACRO\"&gt;&gt;\n              , range =&gt;\n                  #{ 'end' =&gt; #{ character =&gt; 20\n                               , line =&gt; 5\n                               }\n                   , start =&gt; #{ character =&gt; 8\n                               , line =&gt; 5\n                               }\n                   }\n              , severity =&gt; ?DIAGNOSTIC_WARNING\n              , source =&gt; &lt;&lt;\"UnusedMacros\"&gt;&gt;\n              }\n           ],\n?assertEqual(Expected, Diagnostics),\nok.\n</code></pre> <p>Here we verify that a warning message is generated by our backend (notice the <code>source</code> attribute). The warning message is expected on line 6, between characters 8 and 20 (which correspond to the location of the macro name).</p> <p>The <code>?DIAGNOSTIC_WARNING</code> macro is defined in the <code>erlang_ls.hrl</code> header file, so let's include it below the <code>export</code> list:</p> <pre><code>-include(\"erlang_ls.hrl\").\n</code></pre> <p>Let's now execute our test case and check the result. Notice how we need to specify a <code>group</code> for the testcase, since all Erlang LS tests can be run for the two LSP supported transports (TCP and stdio).</p> <pre><code>$ rebar3 ct --suite els_diagnostics_SUITE --case unused_macros --group tcp\n===&gt; Verifying dependencies...\n===&gt; Analyzing applications...\n===&gt; Compiling erlang_ls\n===&gt; Running Common Test suites...\n%%% els_diagnostics_SUITE:\n[...]\nexpected: [#{message =&gt; &lt;&lt;\"Unused macro: UNUSED_MACRO\"&gt;&gt;,\n             range =&gt;\n               #{'end' =&gt; #{character =&gt; 20,line =&gt; 5},\n                 start =&gt; #{character =&gt; 8,line =&gt; 5}},\n             severity =&gt; 2,source =&gt; &lt;&lt;\"UnusedMacros\"&gt;&gt;}]\ngot: []\nline: 582\n</code></pre> <p>Not surpringly, the testcase fails, since we haven't implemented our <code>run/1</code> function yet, but we are returning an hard-coded empty list. Let's fix that now.</p>"},{"location":"articles/tutorial-implementing-diagnostics/#looking-for-unused-macros","title":"Looking for Unused Macros","text":"<p>We can finally jump to interesting bit of this tutorial, implementing a detection mechanism for unused macros. As usual, let's first look at the whole code and then explain its behaviour.</p> <pre><code>run(Uri) -&gt;\n  {ok, [Document]} = els_dt_document:lookup(Uri),\n  UnusedMacros = find_unused_macros(Document),\n  [make_diagnostic(Macro) || Macro &lt;- UnusedMacros].\n</code></pre> <p>First, we query the Erlang LS database by Uri. Then, we invoke the <code>find_unused_macros/1</code> function - which we still need to implement - on the returned document. For each identified Macro, we produce a diagnostic, in the format expected by the LSP protocol. Again, we still need to implement our <code>make_diagnostic/1</code> function.</p> <p>Let's now focus on the <code>find_unused_macros/1</code> function. The goal of the function is to identify unused macros within a given document:</p> <pre><code>find_unused_macros(Document) -&gt;\n  Definitions = els_dt_document:pois(Document, [define]),\n  Usages = els_dt_document:pois(Document, [macro]),\n  UsagesIds = [Id || #{id := Id} &lt;- Usages],\n  [POI || #{id := Id} = POI &lt;- Definitions, not lists:member(Id, UsagesIds)].\n</code></pre> <p>Again, lot of things happening here, so let's go through the code line by line.</p> <p>First, we identify all the macro definitions, identified by the <code>define</code> key:</p> <pre><code>  Definitions = els_dt_document:pois(Document, [define]),\n</code></pre> <p>Then, we identify all the macro usages, identifie by the <code>macro</code> key:</p> <pre><code>  Usages = els_dt_document:pois(Document, [macro]),\n</code></pre> <p>You can refer to the <code>els_parser</code> module in Erlang LS for details about POIs (Points of Interests) and available keys.</p> <p>For each macro usage, we extract the respective <code>id</code> and we return the list of macro definitions which do not have a corresponding usage:</p> <pre><code>  UsagesIds = [Id || #{id := Id} &lt;- Usages],\n  [POI || #{id := Id} = POI &lt;- Definitions, not lists:member(Id, UsagesIds)].\n</code></pre> <p>The last missing bit is the <code>make_diagnostic/1</code> function, which will convert each POI into a diagnostic:</p> <pre><code>make_diagnostic(#{id := Id, range := POIRange} = _POI) -&gt;\n  Range = els_protocol:range(POIRange),\n  MacroName = atom_to_binary(Id, utf8),\n  Message = &lt;&lt;\"Unused macro: \", MacroName/binary&gt;&gt;,\n  Severity = ?DIAGNOSTIC_WARNING,\n  Source = source(),\n  els_diagnostics:make_diagnostic(Range, Message, Severity, Source).\n</code></pre> <p>This function is essentially a wrapper around around the utility function <code>els_diagnostics:make_diagnostic/4</code>. Let's analyze it in detail.</p> <pre><code>  Range = els_protocol:range(POIRange),\n</code></pre> <p>Here we convert the range of the POI (the unused macro definition) in the format required by the LSP protocol, using a helper function provided by Erlang LS.</p> <pre><code>  MacroName = atom_to_binary(Id, utf8),\n  Message = &lt;&lt;\"Unused macro: \", MacroName/binary&gt;&gt;,\n</code></pre> <p>We then build the diagnostic message using the id (the name) of the offending macro.</p> <pre><code>  Severity = ?DIAGNOSTIC_WARNING,\n</code></pre> <p>We specify warning as the severity of the message.</p> <pre><code>  Source = source(),\n</code></pre> <p>We invoke the <code>source/0</code> function to specify the source of the diagnostic (for rendering purposes in the IDE).</p> <pre><code>  els_diagnostics:make_diagnostic(Range, Message, Severity, Source).\n</code></pre> <p>We finally invoke the <code>els_diagnostics:make_diagnostic/4</code> function with the constructed arguments to produce a diagnostic.</p> <p>That should be it. Let's try to execute the testcase again:</p> <pre><code>$ rebar3 ct --suite els_diagnostics_SUITE --case unused_macros --group tcp\n===&gt; Verifying dependencies...\n===&gt; Analyzing applications...\n===&gt; Compiling erlang_ls\n===&gt; Running Common Test suites...\n%%% els_diagnostics_SUITE:\nAll 1 tests passed.\n</code></pre> <p>Success! Tests now pass and we are able to identify unused macros in Erlang LS!</p>"},{"location":"articles/tutorial-implementing-diagnostics/#the-complete-backend","title":"The Complete Backend","text":"<p>Here is the full implementation of the backend, for reference:</p> <pre><code>-module(els_unused_macros_diagnostics).\n-behaviour(els_diagnostics).\n\n-export([ is_default/0\n        , source/0\n        , run/1\n        ]).\n\n-include(\"erlang_ls.hrl\").\n\nis_default() -&gt; true.\n\nsource() -&gt; &lt;&lt;\"UnusedMacros\"&gt;&gt;.\n\nrun(Uri) -&gt;\n  {ok, [Document]} = els_dt_document:lookup(Uri),\n  UnusedMacros = find_unused_macros(Document),\n  [make_diagnostic(Macro) || Macro &lt;- UnusedMacros].\n\nfind_unused_macros(Document) -&gt;\n  Definitions = els_dt_document:pois(Document, [define]),\n  Usages = els_dt_document:pois(Document, [macro]),\n  UsagesIds = [Id || #{id := Id} &lt;- Usages],\n  [POI || #{id := Id} = POI &lt;- Definitions, not lists:member(Id, UsagesIds)].\n\nmake_diagnostic(#{id := Id, range := POIRange} = _POI) -&gt;\n  Range = els_protocol:range(POIRange),\n  MacroName = atom_to_binary(Id, utf8),\n  Message = &lt;&lt;\"Unused macro: \", MacroName/binary&gt;&gt;,\n  Severity = ?DIAGNOSTIC_WARNING,\n  Source = source(),\n  els_diagnostics:make_diagnostic(Range, Message, Severity, Source).\n</code></pre> <p>Of course, the implementation above is quite minimalistic and could be improved in many ways, but at this point you should get the idea of what it means to implement a new diagnostics backend for Erlang LS.</p>"},{"location":"articles/tutorial-implementing-diagnostics/#conclusion","title":"Conclusion","text":"<p>The above backend is already integrated in Erlang LS, but as an opt-in backend. You can see the whole contribution at:</p> <p>https://github.com/erlang-ls/erlang_ls/pull/867/files</p> <p>Contributing to an open source can be a daunting experience, especially when you do not have an infinite amount of time available. I hope that this little tutorial can help you in that direction and I'm looking forward to the brilliant things that you can contribute to Erlang LS.</p> <p>Have fun!</p>"},{"location":"getting-started/emacs/","title":"Emacs","text":""},{"location":"getting-started/emacs/#setup","title":"Setup","text":"<p>The official <code>lsp-mode</code> package includes a client for the Erlang Language Server.</p> <p>Here you can find a sample Emacs configuration file which installs and configures all packages required to get all of the Erlang LS features working. Use this configuration file as a starting point for your Erlang LS Emacs configuration.</p> <p>Whenever opening a project for the first time, you will be prompted by <code>emacs-lsp</code> to select the correct project root. In that occasion, you also have the opportunity to blacklist projects. Information about projects is stored in a file pointed by the <code>lsp-session-file</code> variable. Its default location is <code>~/.emacs.d/.lsp-session-v1</code>. You may need to prune or amend this file if you change your mind about blacklisting a project or if you erroneously select a project root. For more information about the <code>lsp-session-file</code> and <code>emacs-lsp</code> in general, please refer to the official documentation.</p> <p>Remember that the Erlang Language Server requires Erlang/OTP 21 or higher to run, so ensure that OTP 21+ is available in your <code>PATH</code>. This can be achieved, for example, by using the exec-path-from-shell Emacs package.</p>"},{"location":"getting-started/emacs/#restarting-the-language-server","title":"Restarting the language server","text":"<p>You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so:</p> <pre><code>M-x lsp-workspace-restart\n</code></pre>"},{"location":"getting-started/emacs/#troubleshooting","title":"Troubleshooting","text":"<p>If things do not work as expected, we advise you to start Emacs with only the configuration from the provided sample file, using the following command:</p> <pre><code>emacs -q -l [PATH-TO-ERLANG-LS]/misc/dotemacs\n</code></pre> <p>This will remove from the equation potential incompatibilities with other packages or configurations that you may have on your workstation and that could conflict with Erlang LS.</p> <p>To be sure that you don't have outdated or incompatible packages installed, you may also want to rename your <code>~/.emacs.d</code> directory while you are troubleshooting your Erlang LS Emacs setup.</p> <p>Also, ensure that Erlang (i.e. <code>erl</code>, <code>escript</code> and friends) and the <code>erlang_ls</code> executable are all available in your <code>PATH</code>. If they are not, you can try the following:</p> <pre><code>;; Ensure your Emacs environment looks like your user's shell one\n(package-require 'exec-path-from-shell)\n(exec-path-from-shell-initialize)\n</code></pre> <p>Finally, to enable logging on the client-side, just:</p> <pre><code>(setq lsp-log-io t)\n</code></pre> <p>You can then follow the client logs for the current workspace by doing:</p> <pre><code>M-x lsp-workspace-show-log\n</code></pre>"},{"location":"getting-started/emacs/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"getting-started/emacs/#shortcuts-for-code-lenses-and-quick-actions","title":"Shortcuts for code lenses and quick actions","text":"<p>You can run <code>M-x lsp-avy-lens</code> to show letters next to code lenses. You can then press those letters to trigger the respective action.</p> <p>If your <code>sideline</code> is enabled (<code>(setq lsp-ui-sideline-enable t)</code>), you can also use <code>M-x lsp-execute-code-action</code> to trigger quick-fix actions.</p>"},{"location":"getting-started/helix/","title":"Helix","text":"<p>The Helix editor has a built-in LSP client that supports ErlangLS out-of-the-box.</p>"},{"location":"getting-started/helix/#installation","title":"Installation","text":"<p>First, make sure you have a recent Helix installation. ErlangLS configuration was added in 22.05. If you're running an older build, you may configure ErlangLS in the language configuration file:</p> <pre><code>[[language]]\nname = \"erlang\"\nlanguage-server.command = \"erlang_ls\"\n</code></pre> <p>Install ErlangLS on your system. The <code>erlang_ls</code> executable must be in <code>$PATH</code>.</p>"},{"location":"getting-started/helix/#troubleshooting","title":"Troubleshooting","text":"<p>Use <code>hx --health erlang</code> to check that Helix can find ErlangLS.</p> <p>Run Helix in verbose mode with <code>hx -v</code> (up to three <code>v</code>s) and check the log file to debug communication between Helix and ErlangLS.</p>"},{"location":"getting-started/helix/#tips-and-tricks","title":"Tips and Tricks","text":"<p>LSP-driven auto-format is disabled by default. You can enable auto-format local to a project by adding a <code>.helix/languages.toml</code>:</p> <pre><code>[[language]]\nname = \"erlang\"\nauto-format = true\n</code></pre> <p>Or globally in the language configuration file.</p>"},{"location":"getting-started/intellij/","title":"IntelliJ","text":""},{"location":"getting-started/intellij/#setup","title":"Setup","text":"<p>WARNING: The current version of the IntelliJ LSP plugin (1.6.1) is quite limited, so not all of the Erlang Language Server capabilities are available in IntelliJ.</p>  <p>First of all, ensure you have the LSP Support plugin installed. If you don't, you can simply navigate to:</p> <pre><code>Preferences &gt; Plugins &gt; Browse Repositories\n</code></pre> <p>Search for \"LSP Support\" and install the respective plugin.</p> <p>Restart IntelliJ, then navigate to:</p> <pre><code>Preferences &gt; Languages and Frameworks &gt; Language Server Protocol &gt; Server Definitions\n</code></pre> <p>There you can instruct IntelliJ on how to start the server. Select <code>Raw Command</code>, set <code>erl;hrl</code> as the extension, then add as the command:</p> <pre><code>/ABSOLUTE/PATH/TO/erlang_ls/_build/default/bin/erlang_ls --transport stdio\n</code></pre> <p>Ensure you use an absolute path. The plugin does not seem to understand the <code>~</code> symbol. For the above command to work, IntelliJ requires the <code>PATH</code> variable to be correctly configured to include Erlang 20+. To circumvent this issues on Mac OS, the best way is to start IntelliJ from the terminal (i.e. via the <code>idea</code> command) and not via Spotlight.</p> <p>To visualize documentation and type specs while hovering a function, ensure the Show quick documentation on mouse move option is enabled in your IntelliJ preferences:</p> <pre><code>Preferences &gt; Editor &gt; General\n</code></pre> <p>There, you can also set a delay in milliseconds.</p> <p>For more information about how to configure the IntelliJ LSP Client, please refer to the project GitHub page.</p>"},{"location":"getting-started/intellij/#troubleshooting","title":"Troubleshooting","text":"<p>In some cases, the IntelliJ LSP client may not be able to connect to the server. In such cases, the first step is to enable logging:</p> <pre><code>Preferences &gt; Languages and Frameworks &gt; Language Server Protocol\n</code></pre> <p>Check the Log servers communications check-box there.</p> <p>After restarting IntelliJ, you will notice an extra <code>lsp</code> directory created inside your Erlang project. This directory contains the <code>error</code> and <code>output</code> logs, which should give you a hint about what is going on.</p> <p>An alternative source of information is represented by the IntelliJ logs:</p> <pre><code>Help &gt; Show Logs\n</code></pre>"},{"location":"getting-started/kakoune/","title":"Kakoune","text":"<p>The Kakoune editor provides support for Erlang LS via the Kakoune Language Server Protocol Client (kak-lsp) Kakoune plugin.</p>"},{"location":"getting-started/kakoune/#step-0-use-a-recent-kakoune-installation","title":"Step 0: Use a recent Kakoune installation","text":"<p>Make sure you have a recent Kakoune installation. Package managers may carry very old versions of Kakoune.</p> <p>Tips:</p> <ul> <li>Building Kakoune from source is easy and will give you the latest features</li> <li>If you follow the steps on this page, Erlang LS should work in Kakoune. However you will probably want to see syntax highlighting for Erlang in addition to the features that Erlang LS provides like goto definition etc. That is available only in the <code>Kakoune 2021.10.28</code> tagged release (and later) or on current git sources</li> </ul>"},{"location":"getting-started/kakoune/#step-1-install-erlang-ls","title":"Step 1: Install Erlang LS","text":"<p>Install Erlang LS on your system. You may or may not decide to put the <code>erlang_ls</code> executable on your <code>$PATH</code>.</p>"},{"location":"getting-started/kakoune/#step-2-install-kak-lsp","title":"Step 2: Install <code>kak-lsp</code>","text":"<p>Install or build <code>kak-lsp</code> from source by following instructions on its repository.</p>"},{"location":"getting-started/kakoune/#step-3-edit-the-kak-lsp-configuration","title":"Step 3: Edit the <code>kak-lsp</code> configuration","text":"<p>Look for <code>kak-lsp.toml</code>. This file has language specific settings for the Kakoune kak-lsp plugin.</p> <p>On Linux, configuration for <code>kak-lsp</code> should usually live at <code>$HOME/.config/kak-lsp/kak-lsp.toml</code> where <code>$HOME</code> is your home directory.</p> <p>Open <code>kak-lsp.toml</code> in your favorite editor (Kakoune \ud83d\ude04?), look for <code>[language.erlang]</code>. It should look something like this:</p> <pre><code>[language.erlang]\nfiletypes = [\"erlang\"]\n# See https://github.com/erlang-ls/erlang_ls.git for more information and\n# how to configure. This default config should work in most cases though.\nroots = [\"rebar.config\", \"erlang.mk\", \".git\", \".hg\"]\ncommand = \"erlang_ls\"\n</code></pre> <p>Tip: If you don't find <code>[language.erlang]</code> your probably have an older version of <code>kak-lsp</code>. Nevermind, you can add this <code>toml</code> snippet yourself to <code>kak-lsp.toml</code> without any issues</p>"},{"location":"getting-started/kakoune/#if-the-erlang_ls-executable-is-on-your-path","title":"If the <code>erlang_ls</code> executable is on your <code>$PATH</code>","text":"<p>Save <code>kak-lsp.toml</code> if you added the above snippet and restart Kakoune.</p> <p>You're done! Erlang LS should work now on Erlang projects and sources!</p>"},{"location":"getting-started/kakoune/#if-the-erlang_ls-executable-is-not-on-your-path","title":"If the <code>erlang_ls</code> executable is not on your <code>$PATH</code>","text":"<p>Change the <code>command</code> line for the <code>[language.erlang]</code> section to:</p> <pre><code>command = \"/the/path/to/erlang_ls\"\n</code></pre> <p>Don't forget to save the file and restart Kakoune!</p>"},{"location":"getting-started/overview/","title":"Getting Started","text":"<p>The Erlang LS language server works with all text editors and IDEs which adhere to the LSP protocol. The list of supported editors include Emacs, Vim, VS Code, Sublime Text 3 and more.</p> <p>These pages contain all the information needed to configure your favourite text editor or IDE to use Erlang LS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected.</p> <ul> <li>Emacs</li> <li>Spacemacs</li> <li>VS Code</li> <li>Sublime Text 3</li> <li>IntelliJ</li> <li>Kakoune</li> <li>Vim</li> <li>Theia IDE</li> <li>Helix</li> </ul>"},{"location":"getting-started/spacemacs/","title":"Spacemacs","text":""},{"location":"getting-started/spacemacs/#setup","title":"Setup","text":"<p>The <code>develop</code> branch includes an Erlang layer with support for the Language Server Protocol using Erlang LS as backend.</p> <p>Here you can find information about installation and configuration, as well as supported features.</p> <p>Both, <code>lsp</code> and <code>erlang-mode</code> variables, can be configured when setting up <code>dotspacemacs-configuration-layers</code>, e.g:</p> <pre><code>dotspacemacs-configuration-layers\n'(\n;...\nlsp\n(erlang :variables\n        erlang-backend 'lsp\n        erlang-root-dir \"&lt;path to&gt;/otp_22/lib/erlang\"\n        erlang-man-root-dir \"&lt;path to&gt;/otp_22_kred/lib/erlang/man\"\n        erlang-fill-column 100\n        company-minimum-prefix-length 1\n        company-idle-delay 0.3\n        lsp-ui-doc-position 'bottom)\n;...\n)\n</code></pre>"},{"location":"getting-started/sublime3/","title":"Sublime Text 3","text":""},{"location":"getting-started/sublime3/#setup","title":"Setup","text":""},{"location":"getting-started/sublime3/#install-the-erlang-ls-language-server","title":"Install the Erlang LS Language Server","text":"<p>To install Erlang LS:</p> <pre><code>git clone https://github.com/erlang-ls/erlang_ls\ncd erlang_ls\nrebar3 escriptize\n</code></pre> <p>This will create an Erlang escript in:</p> <pre><code>_build/default/bin/erlang_ls\n</code></pre> <p>Try running Erlang LS with the <code>--version</code> flag to verify everything works as expected:</p> <pre><code>_build/default/bin/erlang_ls --version\n</code></pre> <p>Ensure <code>erlang_ls</code> is in your <code>PATH</code>.</p>"},{"location":"getting-started/sublime3/#install-the-lsp-client-for-sublime-text-3","title":"Install the LSP Client for Sublime Text 3","text":"<p>Using the Command Palette from the Tools menu, select <code>Package Control: Install Package</code> and install the <code>LSP</code> package.</p> <p>After that is done, go to:</p> <pre><code>Preferences -&gt; Package Settings -&gt; LSP -&gt; Settings\n</code></pre> <p>Add an Erlang client by adding the following configuration to the <code>LSP.sublime-settings - User</code> file:</p> <pre><code>{\n  \"clients\":\n    {\n      \"erlang-ls\":\n        {\n          \"command\"   : [ \"erlang_ls\", \"--transport\", \"stdio\" ],\n          \"enabled\"   : true,\n          \"languageId\": \"erlang\",\n          \"scopes\"    : [ \"source.erlang\" ],\n          \"syntaxes\"  : [\"Packages/Erlang/Erlang.sublime-syntax\"]\n        }\n    },\n  // Allow up to 30 secs to `erlang_ls` to respond to `initialize`\n  // (it requires less, but just to be on the safe side)\n  \"initialize_timeout\": 30\n}\n</code></pre> <p>That's it. Open a new Erlang project and enjoy Erlang LS.</p>"},{"location":"getting-started/sublime3/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/sublime3/#ensure-erlang-ls-is-in-your-path","title":"Ensure Erlang LS is in your PATH","text":"<p>To be able to use Erlang LS, the <code>erlang_ls</code> escript needs to be in your path.</p>  <p>Are You a macOS User?</p> <p>If you are a macOS user, you may consider using the following plugin to ensure your PATH is correctly used by Sublime Text 3: https://github.com/int3h/SublimeFixMacPath</p>"},{"location":"getting-started/sublime3/#enabling-logging","title":"Enabling logging","text":"<p>In case of issues, you can enable extra logging for the <code>LSP</code> package by adding the following configuration to your <code>LSP.sublime-settings - User</code> file:</p> <pre><code>{\n  // Show verbose debug messages in the sublime console.\n  \"log_debug\": true,\n\n  // Show messages from language servers in the Language Servers output\n  // panel.\n \"log_server\": true,\n\n  // Show language server stderr output in the Language Servers output\n  // panel.\n  \"log_stderr\": true,\n\n  // Show full JSON-RPC requests/responses/notifications in the Language\n  // Servers output panel.\n  \"log_payloads\": true\n}\n</code></pre> <p>The Sublime console can be toggled using the <code>Ctrl-`</code> shortcut. The output panel can be toggled from the command palette with the command <code>LSP: Toggle Panel: Language Servers</code>.</p>"},{"location":"getting-started/theia/","title":"Theia IDE","text":""},{"location":"getting-started/theia/#setup","title":"Setup","text":"<p>It is possible to use Erlang LS in Theia IDE by including Erlang/OTP in your running instance and installing the VSCode extension.</p> <p>If you want to give it a try by using GitPod click here. To use this same setup with your Erlang project (hosted in GitHub or Gitlab) you can find the GitPod configuration in <code>.gitpod.yml</code>.</p>"},{"location":"getting-started/vim/","title":"Vim / NeoVim","text":""},{"location":"getting-started/vim/#setup-using-coc","title":"Setup using Coc","text":"<p>The following instructions should enable Erlang language server integration via the Coc system (an intellisense engine for both Vim and Neovim).</p>"},{"location":"getting-started/vim/#installing-coc-with-vim-plug","title":"Installing Coc with vim-plug","text":"<p>For vim-plug users with nodejs &gt;= 10.12 installed, installing the plugin is just:</p> <pre><code>\" Use release branch (Recommended)\nPlug 'neoclide/coc.nvim', {'branch': 'release'}\n</code></pre> <p>To make the plugin aware of erlang_ls however, it needs configuration.</p>"},{"location":"getting-started/vim/#coc-plugin-configuration","title":"Coc plugin configuration","text":"<p>Coc is configured through <code>coc-settings.json</code>, which can be opened in vim by  issuing the command: <pre><code>:CocConfig\n</code></pre></p> <p>If <code>erlang_ls</code> is present in your <code>$PATH</code> variable then the following config should suffice: <pre><code>{\n  \"languageserver\": {\n    \"erlang\": {\n      \"command\": \"erlang_ls\",\n      \"filetypes\": [\"erlang\"]\n    }\n  }\n}\n</code></pre></p> <p>When vim starts editing a file of filetype <code>erlang</code>, if the erlang_ls server can be started and connected to, you should see something like the following message from Coc:</p> <pre><code>[coc.nvim] Erlang LS (in erlang_ls), version: X.Y.Z+build.REF\n</code></pre> <p>For suggestions on configuring Coc and possible key-bindings see its example configuration documentation.</p>"},{"location":"getting-started/vim/#setup-for-neovim-using-the-built-in-language-server-client","title":"Setup for Neovim using the built-in language server client","text":"<p>The following instructions should enable Erlang language server integration using the built-in language server client in Neovim. The nvim-lspconfig plugin is used to configure, launch, and initialize the language server.</p>"},{"location":"getting-started/vim/#installing-nvim-lspconfig","title":"Installing nvim-lspconfig","text":"<p>Install using, for example, vim-plug:</p> <pre><code>Plug 'neovim/nvim-lspconfig'\n</code></pre>"},{"location":"getting-started/vim/#enable-the-language-server","title":"Enable the language server","text":"<p>Add the following setup call to your <code>init.vim</code> to make the language server attach to Erlang files:</p> <pre><code>lua require'lspconfig'.erlangls.setup{}\n</code></pre> <p>Now, when you open an Erlang file you should see a message like this:</p> <p><code>LSP[erlangls][Info] Erlang LS (in &lt;your-project&gt;), version: ..., OTP version: ...</code></p> <p>Test it by writing some incorrect code. You should see a syntax error message. Run <code>:LspInfo</code> to get the status of active and configured language servers.</p>"},{"location":"getting-started/vim/#configuration","title":"Configuration","text":"<p>There are no default keybindings for the LSP commands. You can find a good example on how to set these up in the Keybindings and completion section on the nvim-lspconfig plugin page. The idea is to create a function that sets up your keybindings and configuration, which is passed to the setup function in the previous section. This function is then called when the Erlang language server is attached. See the Neovim LSP documentation for more information.</p>"},{"location":"getting-started/vim/#example","title":"Example","text":"<pre><code>\" init.vim\n...\nlua require'lspconfig'.erlangls.setup{}\n\nlua &lt;&lt; EOF\nlocal nvim_lsp = require('lspconfig')\nlocal on_attach = function(client, bufnr)\n  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end\n  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end\n\n  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')\n\n  -- Mappings.\n  local opts = { noremap=true, silent=true }\n  buf_set_keymap('n', 'gD', '&lt;cmd&gt;lua vim.lsp.buf.declaration()&lt;CR&gt;', opts)\n  buf_set_keymap('n', 'gd', '&lt;cmd&gt;lua vim.lsp.buf.definition()&lt;CR&gt;', opts)\n  buf_set_keymap('n', 'K', '&lt;cmd&gt;lua vim.lsp.buf.hover()&lt;CR&gt;', opts)\n  buf_set_keymap('n', 'gi', '&lt;cmd&gt;lua vim.lsp.buf.implementation()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;C-k&gt;', '&lt;cmd&gt;lua vim.lsp.buf.signature_help()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;wa', '&lt;cmd&gt;lua vim.lsp.buf.add_workspace_folder()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;wr', '&lt;cmd&gt;lua vim.lsp.buf.remove_workspace_folder()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;wl', '&lt;cmd&gt;lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;D', '&lt;cmd&gt;lua vim.lsp.buf.type_definition()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;rn', '&lt;cmd&gt;lua vim.lsp.buf.rename()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;ca', '&lt;cmd&gt;lua vim.lsp.buf.code_action()&lt;CR&gt;', opts)\n  buf_set_keymap('n', 'gr', '&lt;cmd&gt;lua vim.lsp.buf.references()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;e', '&lt;cmd&gt;lua vim.lsp.diagnostic.show_line_diagnostics()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '[d', '&lt;cmd&gt;lua vim.lsp.diagnostic.goto_prev()&lt;CR&gt;', opts)\n  buf_set_keymap('n', ']d', '&lt;cmd&gt;lua vim.lsp.diagnostic.goto_next()&lt;CR&gt;', opts)\n  buf_set_keymap('n', '&lt;space&gt;q', '&lt;cmd&gt;lua vim.lsp.diagnostic.set_loclist()&lt;CR&gt;', opts)\n\n  -- Set some keybinds conditional on server capabilities\n  if client.resolved_capabilities.document_formatting then\n    buf_set_keymap(\"n\", \"&lt;space&gt;f\", \"&lt;cmd&gt;lua vim.lsp.buf.formatting()&lt;CR&gt;\", opts)\n  end\n  if client.resolved_capabilities.document_range_formatting then\n    buf_set_keymap(\"v\", \"&lt;space&gt;f\", \"&lt;cmd&gt;lua vim.lsp.buf.range_formatting()&lt;CR&gt;\", opts)\n  end\n\n  -- Set autocommands conditional on server_capabilities\n  if client.resolved_capabilities.document_highlight then\n    vim.api.nvim_exec([[\n      hi LspReferenceRead cterm=bold ctermbg=Grey guibg=LightYellow\n      hi LspReferenceText cterm=bold ctermbg=Grey guibg=LightYellow\n      hi LspReferenceWrite cterm=bold ctermbg=Grey guibg=LightYellow\n      augroup lsp_document_highlight\n        autocmd! * &lt;buffer&gt;\n        autocmd CursorHold &lt;buffer&gt; lua vim.lsp.buf.document_highlight()\n        autocmd CursorMoved &lt;buffer&gt; lua vim.lsp.buf.clear_references()\n      augroup END\n    ]], false)\n  end\nend\n\n -- Use a loop to conveniently both setup defined servers \n -- and map buffer local keybindings when the language server attaches\n local servers = { \"erlangls\" }\n for _, lsp in ipairs(servers) do\n  nvim_lsp[lsp].setup { on_attach = on_attach }\n end\n\nEOF\n</code></pre>"},{"location":"getting-started/vim/#tips-and-tricks","title":"Tips and tricks","text":"<p>Run <code>:h vim.diagnostic.config</code> inside Neovim for instructions on how to display diagnostics. <code>:h vim.lsp.codelens.refresh</code> describes how to show code lenses.</p>"},{"location":"getting-started/vscode/","title":"VSCode","text":""},{"location":"getting-started/vscode/#setup","title":"Setup","text":"<p>The Erlang Language Server is available in VSCode via a dedicated extension.</p> <p>To try it out, simply open VSCode and install the extension via the Marketplace:</p> <pre><code>Preferences &gt; Extensions\n</code></pre> <p>Look for the <code>erlang-ls</code> extension and install it. That's it.</p> <p>Remember that the Erlang Language Server requires Erlang/OTP 21 or higher to run, so ensure that OTP 21+ is available in your <code>PATH</code>.</p>"},{"location":"getting-started/vscode/#restarting-the-language-server","title":"Restarting the language server","text":"<p>You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so:</p> <pre><code>View -&gt; Command Palette... -&gt; Developer: Reload Window\n</code></pre> <p>On Mac OS you can use the <code>Cmd+Shift+P</code> shortcut to quickly access the command palette.</p>"}]}