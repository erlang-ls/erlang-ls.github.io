{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Erlang LS Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice. A brilliant intuition, the Language Server Protocol , also known as LSP , changes the rules of the game. A real blessing for the Erlang community. Erlang LS is a language server providing language features for the Erlang programming language. The server works with Emacs , VSCode , Sublime Text 3 , Vim and probably many more text editors and IDE which adhere to the LSP protocol. These pages contain all the information needed to configure your favourite text editor or IDE and to work with Erlang LS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected. Get in touch If you have any questions about the project, feel free to open a new issue on GitHub. You can also join the #erlang-ls channel in the Erlanger Slack if you would like to get involved or if you prefer a more informal mean of communication. All contributions are welcome, be them in the form of a bug report, a question, feedback, or code.","title":"Overview"},{"location":"#welcome-to-erlang-ls","text":"Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice. A brilliant intuition, the Language Server Protocol , also known as LSP , changes the rules of the game. A real blessing for the Erlang community. Erlang LS is a language server providing language features for the Erlang programming language. The server works with Emacs , VSCode , Sublime Text 3 , Vim and probably many more text editors and IDE which adhere to the LSP protocol. These pages contain all the information needed to configure your favourite text editor or IDE and to work with Erlang LS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected.","title":"Welcome to Erlang LS"},{"location":"#get-in-touch","text":"If you have any questions about the project, feel free to open a new issue on GitHub. You can also join the #erlang-ls channel in the Erlanger Slack if you would like to get involved or if you prefer a more informal mean of communication. All contributions are welcome, be them in the form of a bug report, a question, feedback, or code.","title":"Get in touch"},{"location":"configuration/","text":"Configuration The erlang_ls.config file It is possible to customize the behaviour of the erlang_ls server via a configuration file, named erlang_ls.config . The erlang_ls.config file should be placed in the root directory of a given project to store the configuration for that project. A sample erlang_ls.config file would look like the following: otp_path : \"/path/to/otp/lib/erlang\" deps_dirs : - \"lib/*\" diagnostics : enabled : - crossref disabled : - dialyzer include_dirs : - \"include\" - \"_build/default/lib\" lenses : enabled : - ct-run-test disabled : - show-behaviour-usages macros : - name : DEFINED_WITH_VALUE value : 42 - name : DEFINED_WITHOUT_VALUE code_reload : node : node@example The file format is yaml . The following customizations are possible: Parameter Description apps_dirs List of directories containing project applications. It supports wildcards. code_reload Whether or not an rpc call should be made to a remote node to compile and reload a module deps_dirs List of directories containing dependencies. It supports wildcards. diagnostics Customize the list of active diagnostics include_dirs List of directories provided to the compiler as include dirs. It supports wildcards. incremental_sync Whether or not to support incremental synchronization of text changes in the client. Disabled by default. lenses Customize the list of active code lenses macros List of cusom macros to be passed to the compiler, expressed as a name/value pair. If the value is omitted or is invalid, 'true' is used. otp_apps_exclude List of OTP applications that will not be indexed (default: megaco, diameter, snmp, wx) otp_path Path to the OTP installation plt_path Path to the dialyzer PLT file. When none is provided the dialyzer diagnostics will not be available. code_path_extra_dirs List of wildcard Paths erlang_ls will add with code:add_path/1 elvis_config_path Path to the elvis.config file. Defaults to ROOT_DIR/elvis.config Diagnostics When a file is open or saved, a list of diagnostics are run in the background, reporting eventual issues with the code base to the editor. The following diagnostics are available: Diagnostic Name Purpose compiler Report in-line warnings and errors from the Erlang compiler dialyzer Use the dialyzer static analysis tool to find discrepancies in your code elvis Use elvis to review the style of your Erlang code crossref Use information from the Erlang LS Database to find out about undefined functions Currently, all of the available diagnostics are enabled by default. It is possible to customize diagnostics for a specific project. For example: diagnostics: disabled: - dialyzer - crossref Automatic Code Reloading The code_reload takes the following options: Parameter Description node The node to be called for code reloading. Example erlang_ls@hostname Code Lenses Code Lenses are also available in Erlang LS. The following lenses are available in Erlang LS: Code Lens Name Purpose ct-run-test Display a run button next to a Common Test testcase server-info Display some Erlang LS server information on the top of each module. For debug only. show-behaviour-usages Show the number of modules implementing a behaviour The following lenses are enabled by default: show-behaviour-usages It is possible to customize lenses for a specific project. For example: lenses: enabled: - ct-run-test disabled: - show-behaviour-usages Global Configuration It is also possible to store a system-wide default configuration in an erlang_ls.config file located in the User Config directory. The exact location of the User Config directory depends on the operating system used and it can be identified by executing the following command on an Erlang shell: > filename:basedir(user_config, \"erlang_ls\"). Normally, the location of the User Config directory is: Operating System User Config Directory Linux /home/USER/.config/erlang_ls OS X /Users/USER/Library/Application\\ Support/erlang_ls Windows c:/Users/USER/AppData/Local/erlang_ls Thus on Linux, for example, the full path to the default configuation file would be /home/USER/.config/erlang_ls/erlang_ls.config Common configurations Many Erlang repositories follow the same structure. We include common Erlang LS configurations in this section, for easy reuse. rebar3 project The following configuration can be used for most rebar3 based projects. apps_dirs : - \"_build/default/lib/*\" include_dirs : - \"_build/default/lib/*/include\" - \"include\" rebar3 umbrella project If your rebar3 project includes multiple application (e.g. in an apps folder), you may want to adapt your Erlang LS configuration as follows. apps_dirs : - \"apps/*\" deps_dirs : - \"_build/default/lib/*\" include_dirs : - \"apps\" - \"apps/*/include\" - \"_build/default/lib/\" - \"_build/default/lib/*/include\" The erlang/otp repository To be able to use the major Erlang LS features with the erlang/otp repository, the following minimal configuration should suffice. otp_path : \"/Users/robert.aloi/otp/23-kred\" apps_dirs : - \"lib/*\" include_dirs : - \"lib\" - \"lib/*/include\"","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#the-erlang_lsconfig-file","text":"It is possible to customize the behaviour of the erlang_ls server via a configuration file, named erlang_ls.config . The erlang_ls.config file should be placed in the root directory of a given project to store the configuration for that project. A sample erlang_ls.config file would look like the following: otp_path : \"/path/to/otp/lib/erlang\" deps_dirs : - \"lib/*\" diagnostics : enabled : - crossref disabled : - dialyzer include_dirs : - \"include\" - \"_build/default/lib\" lenses : enabled : - ct-run-test disabled : - show-behaviour-usages macros : - name : DEFINED_WITH_VALUE value : 42 - name : DEFINED_WITHOUT_VALUE code_reload : node : node@example The file format is yaml . The following customizations are possible: Parameter Description apps_dirs List of directories containing project applications. It supports wildcards. code_reload Whether or not an rpc call should be made to a remote node to compile and reload a module deps_dirs List of directories containing dependencies. It supports wildcards. diagnostics Customize the list of active diagnostics include_dirs List of directories provided to the compiler as include dirs. It supports wildcards. incremental_sync Whether or not to support incremental synchronization of text changes in the client. Disabled by default. lenses Customize the list of active code lenses macros List of cusom macros to be passed to the compiler, expressed as a name/value pair. If the value is omitted or is invalid, 'true' is used. otp_apps_exclude List of OTP applications that will not be indexed (default: megaco, diameter, snmp, wx) otp_path Path to the OTP installation plt_path Path to the dialyzer PLT file. When none is provided the dialyzer diagnostics will not be available. code_path_extra_dirs List of wildcard Paths erlang_ls will add with code:add_path/1 elvis_config_path Path to the elvis.config file. Defaults to ROOT_DIR/elvis.config","title":"The erlang_ls.config file"},{"location":"configuration/#diagnostics","text":"When a file is open or saved, a list of diagnostics are run in the background, reporting eventual issues with the code base to the editor. The following diagnostics are available: Diagnostic Name Purpose compiler Report in-line warnings and errors from the Erlang compiler dialyzer Use the dialyzer static analysis tool to find discrepancies in your code elvis Use elvis to review the style of your Erlang code crossref Use information from the Erlang LS Database to find out about undefined functions Currently, all of the available diagnostics are enabled by default. It is possible to customize diagnostics for a specific project. For example: diagnostics: disabled: - dialyzer - crossref","title":"Diagnostics"},{"location":"configuration/#automatic-code-reloading","text":"The code_reload takes the following options: Parameter Description node The node to be called for code reloading. Example erlang_ls@hostname","title":"Automatic Code Reloading"},{"location":"configuration/#code-lenses","text":"Code Lenses are also available in Erlang LS. The following lenses are available in Erlang LS: Code Lens Name Purpose ct-run-test Display a run button next to a Common Test testcase server-info Display some Erlang LS server information on the top of each module. For debug only. show-behaviour-usages Show the number of modules implementing a behaviour The following lenses are enabled by default: show-behaviour-usages It is possible to customize lenses for a specific project. For example: lenses: enabled: - ct-run-test disabled: - show-behaviour-usages","title":"Code Lenses"},{"location":"configuration/#global-configuration","text":"It is also possible to store a system-wide default configuration in an erlang_ls.config file located in the User Config directory. The exact location of the User Config directory depends on the operating system used and it can be identified by executing the following command on an Erlang shell: > filename:basedir(user_config, \"erlang_ls\"). Normally, the location of the User Config directory is: Operating System User Config Directory Linux /home/USER/.config/erlang_ls OS X /Users/USER/Library/Application\\ Support/erlang_ls Windows c:/Users/USER/AppData/Local/erlang_ls Thus on Linux, for example, the full path to the default configuation file would be /home/USER/.config/erlang_ls/erlang_ls.config","title":"Global Configuration"},{"location":"configuration/#common-configurations","text":"Many Erlang repositories follow the same structure. We include common Erlang LS configurations in this section, for easy reuse.","title":"Common configurations"},{"location":"configuration/#rebar3-project","text":"The following configuration can be used for most rebar3 based projects. apps_dirs : - \"_build/default/lib/*\" include_dirs : - \"_build/default/lib/*/include\" - \"include\"","title":"rebar3 project"},{"location":"configuration/#rebar3-umbrella-project","text":"If your rebar3 project includes multiple application (e.g. in an apps folder), you may want to adapt your Erlang LS configuration as follows. apps_dirs : - \"apps/*\" deps_dirs : - \"_build/default/lib/*\" include_dirs : - \"apps\" - \"apps/*/include\" - \"_build/default/lib/\" - \"_build/default/lib/*/include\"","title":"rebar3 umbrella project"},{"location":"configuration/#the-erlangotp-repository","text":"To be able to use the major Erlang LS features with the erlang/otp repository, the following minimal configuration should suffice. otp_path : \"/Users/robert.aloi/otp/23-kred\" apps_dirs : - \"lib/*\" include_dirs : - \"lib\" - \"lib/*/include\"","title":"The erlang/otp repository"},{"location":"features/","text":"Features Code Completion Get context-aware code completions for function names, macros, records, variable names and more. Go To Definition Navigate to the definition of a function, macro, record or type. Go To Implementation for OTP Behaviours Hovering a gen_server:start_link call? Jump to the respective init function with a single keystroke. Signature Suggestions Never remember the order of the lists:keytake/3 arguments? You are not alone. We got you covered. Compiler Diagnostics Display warnings and errors from the compiler. Inline. Dialyzer Diagnostics It has never been so easy to make Dialyzer happy. Elvis Diagnostics Display Elvis style suggestions inline. No more nit-picking comments from colleagues! Edoc Hover a local or remote function to see its edoc . You will miss this feature so much when edocs are not available that you will start writing them! Navigation for Included Files Navigate to included files with a single click. Find/Peek References Who is calling this function? Figure it out without leaving the current context. Outline Get a nice outline of your module on the side and jump between functions. Workspace Symbols Jump to the module you're looking for, in no time. Folding Focus on what's important, fold the rest. Snippets Quickly insert parametrized, reusable pieces of code. Suggest Type Specs Annotate your Erlang programs with type information.","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#code-completion","text":"Get context-aware code completions for function names, macros, records, variable names and more.","title":"Code Completion"},{"location":"features/#go-to-definition","text":"Navigate to the definition of a function, macro, record or type.","title":"Go To Definition"},{"location":"features/#go-to-implementation-for-otp-behaviours","text":"Hovering a gen_server:start_link call? Jump to the respective init function with a single keystroke.","title":"Go To Implementation for OTP Behaviours"},{"location":"features/#signature-suggestions","text":"Never remember the order of the lists:keytake/3 arguments? You are not alone. We got you covered.","title":"Signature Suggestions"},{"location":"features/#compiler-diagnostics","text":"Display warnings and errors from the compiler. Inline.","title":"Compiler Diagnostics"},{"location":"features/#dialyzer-diagnostics","text":"It has never been so easy to make Dialyzer happy.","title":"Dialyzer Diagnostics"},{"location":"features/#elvis-diagnostics","text":"Display Elvis style suggestions inline. No more nit-picking comments from colleagues!","title":"Elvis Diagnostics"},{"location":"features/#edoc","text":"Hover a local or remote function to see its edoc . You will miss this feature so much when edocs are not available that you will start writing them!","title":"Edoc"},{"location":"features/#navigation-for-included-files","text":"Navigate to included files with a single click.","title":"Navigation for Included Files"},{"location":"features/#findpeek-references","text":"Who is calling this function? Figure it out without leaving the current context.","title":"Find/Peek References"},{"location":"features/#outline","text":"Get a nice outline of your module on the side and jump between functions.","title":"Outline"},{"location":"features/#workspace-symbols","text":"Jump to the module you're looking for, in no time.","title":"Workspace Symbols"},{"location":"features/#folding","text":"Focus on what's important, fold the rest.","title":"Folding"},{"location":"features/#snippets","text":"Quickly insert parametrized, reusable pieces of code.","title":"Snippets"},{"location":"features/#suggest-type-specs","text":"Annotate your Erlang programs with type information.","title":"Suggest Type Specs"},{"location":"talks/","text":"Talks Boost your Productivity with the Erlang Language Server 2020-09-11 Code BEAM Stockholm (Virtual) Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice. A brilliant intuition, the \"Language Server Protocol\" (LSP), changes the rules of the game. A real blessing for the Erlang community.","title":"Talks"},{"location":"talks/#talks","text":"","title":"Talks"},{"location":"talks/#boost-your-productivity-with-the-erlang-language-server","text":"2020-09-11 Code BEAM Stockholm (Virtual) Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice. A brilliant intuition, the \"Language Server Protocol\" (LSP), changes the rules of the game. A real blessing for the Erlang community.","title":"Boost your Productivity with the Erlang Language Server"},{"location":"troubleshooting/","text":"Troubleshooting Attaching to the Language Server via a Remote Shell Once an instance of the server is running, find the name of the node in the logs or by running epmd -names . It will look something like: $ epmd -names epmd: up and running on port 4369 with data: name erlang_ls_projectname_62880311918 at port 50819 And you can connect to it via: $ erl -sname debug -remsh erlang_ls_projectname_62880311918@`HOSTNAME` If you see this error like this: *** ERROR: Shell process terminated! (^G to start new job) *** =ERROR REPORT==== 5-Jun-2020::15:53:07.270087 === ** System NOT running to use fully qualified hostnames ** ** Hostname Host-Name-Here.local is illegal ** Then try running the command without the @HOSTNAME at the end, like so: $ erl -sname debug -remsh erlang_ls_projectname_62880311918 The redbug application is included in the escript, so feel free to use it. Logging Logs are written to your platform's log directory (i.e. the return value from filename:basedir(user_log, \"erlang_ls\"). ), in a file named server.log . For example on a Mac, the default location is /Users/USERNAME/Library/Logs/erlang_ls/PROJECTDIR/server.log , where USERNAME and PROJECTDIR are your operating system's user account name and the project folder that logs were generated for, respectively. It's possible to customize the logging directory by using the --log-dir option when starting the server. It's also possible to specify the verbosity of the logs by using the --log-level option. In addition to the notice , debug , info , warning and error levels, syslog style loglevel comparison flags can also be used.","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#attaching-to-the-language-server-via-a-remote-shell","text":"Once an instance of the server is running, find the name of the node in the logs or by running epmd -names . It will look something like: $ epmd -names epmd: up and running on port 4369 with data: name erlang_ls_projectname_62880311918 at port 50819 And you can connect to it via: $ erl -sname debug -remsh erlang_ls_projectname_62880311918@`HOSTNAME` If you see this error like this: *** ERROR: Shell process terminated! (^G to start new job) *** =ERROR REPORT==== 5-Jun-2020::15:53:07.270087 === ** System NOT running to use fully qualified hostnames ** ** Hostname Host-Name-Here.local is illegal ** Then try running the command without the @HOSTNAME at the end, like so: $ erl -sname debug -remsh erlang_ls_projectname_62880311918 The redbug application is included in the escript, so feel free to use it.","title":"Attaching to the Language Server via a Remote Shell"},{"location":"troubleshooting/#logging","text":"Logs are written to your platform's log directory (i.e. the return value from filename:basedir(user_log, \"erlang_ls\"). ), in a file named server.log . For example on a Mac, the default location is /Users/USERNAME/Library/Logs/erlang_ls/PROJECTDIR/server.log , where USERNAME and PROJECTDIR are your operating system's user account name and the project folder that logs were generated for, respectively. It's possible to customize the logging directory by using the --log-dir option when starting the server. It's also possible to specify the verbosity of the logs by using the --log-level option. In addition to the notice , debug , info , warning and error levels, syslog style loglevel comparison flags can also be used.","title":"Logging"},{"location":"articles/otp-23-bring-docs/","text":"OTP 23 Brings Docs to the Shell, Erlang LS brings them to you! You may have heard that Erlang/OTP 23 introduces a couple of new functions that can be used for displaying documentation for modules, functions and types in the Erlang shell: 1> h(lists). lists This module contains functions for list processing. Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1. Two terms T1 and T2 compare equal if T1 == T2 evaluates to true. They match if T1 =:= T2 evaluates to true. Whenever an ordering function F is expected as argument, it is assumed that the following properties hold of F for all x, y, and z: \u2022 If x F y and y F x, then x = y (F is antisymmetric). \u2022 If x F y and y F z, then x F z (F is transitive). \u2022 x F y or y F x (F is total). An example of a typical ordering function is less than or equal more (y/n)? (y) This is an amazing improvement, but as developers we often spend a good portion of our time in our IDE of choice, be it VSCode , Emacs , Vim or anything else. Wouldn't it be even more awesome if those pieces of documentation were closer to us in the IDE? It turns out this is something trivial to do. These pieces of documentation are stored as chunks using the format specified in the EEP-48 Erlang Enhancement Proposal and now implemented in OTP 23. Erlang LS already supports chunks , so the documentation for modules, functions and types is now available on hover when using OTP 23. This is how they look in Emacs : To get them, ensure you build your Erlang/OTP distribution with support for Doc Chunks . If you are using kerl , this is as simple as: KERL_BUILD_DOCS=yes KERL_DOC_TARGETS=chunks kerl build 23.0.1 23.0.1 KERL_BUILD_DOCS=yes kerl install 23.0.1 /your/favourite/path/to/23.0.1 Enjoy!","title":"OTP 23 Brings Docs"},{"location":"articles/otp-23-bring-docs/#otp-23-brings-docs-to-the-shell-erlang-ls-brings-them-to-you","text":"You may have heard that Erlang/OTP 23 introduces a couple of new functions that can be used for displaying documentation for modules, functions and types in the Erlang shell: 1> h(lists). lists This module contains functions for list processing. Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1. Two terms T1 and T2 compare equal if T1 == T2 evaluates to true. They match if T1 =:= T2 evaluates to true. Whenever an ordering function F is expected as argument, it is assumed that the following properties hold of F for all x, y, and z: \u2022 If x F y and y F x, then x = y (F is antisymmetric). \u2022 If x F y and y F z, then x F z (F is transitive). \u2022 x F y or y F x (F is total). An example of a typical ordering function is less than or equal more (y/n)? (y) This is an amazing improvement, but as developers we often spend a good portion of our time in our IDE of choice, be it VSCode , Emacs , Vim or anything else. Wouldn't it be even more awesome if those pieces of documentation were closer to us in the IDE? It turns out this is something trivial to do. These pieces of documentation are stored as chunks using the format specified in the EEP-48 Erlang Enhancement Proposal and now implemented in OTP 23. Erlang LS already supports chunks , so the documentation for modules, functions and types is now available on hover when using OTP 23. This is how they look in Emacs : To get them, ensure you build your Erlang/OTP distribution with support for Doc Chunks . If you are using kerl , this is as simple as: KERL_BUILD_DOCS=yes KERL_DOC_TARGETS=chunks kerl build 23.0.1 23.0.1 KERL_BUILD_DOCS=yes kerl install 23.0.1 /your/favourite/path/to/23.0.1 Enjoy!","title":"OTP 23 Brings Docs to the Shell, Erlang LS brings them to you!"},{"location":"articles/snippets-are-here/","text":"Snippets are here Snippets are a convenient way to insert portions of code without having to write them from scratch or to copy them from an external source every single time. To start using snippets, ensure you have the latest version of Erlang LS. Then, simply start typing snippet . A dropdown with all available snippets will appear, so you can select one. A few built-in snippets are available, ranging from a try catch construct to a receive after statement, from a record attribute to edoc blocks. Snippets contain placeholders , which can be used for easier navigation via the TAB key. They also have the concept of a variable , which gets expanded automatically when the snippet is selected. The syntax for snippets is described in detail here . Contributing snippets is trivial and does not require coding. Built-in snippets are stored in the Erlang LS priv directory. It is also possible to add custom snippets by dropping them into: ~/.config/erlang_ls/snippets This mechanism allows your organization to customize snippets, so they match specific coding styles and conventions. A custom snippet which has the same name as built-in one will take precedence, so the former will override the latter in the snippets dropdown. Enjoy!","title":"Snippets are here"},{"location":"articles/snippets-are-here/#snippets-are-here","text":"Snippets are a convenient way to insert portions of code without having to write them from scratch or to copy them from an external source every single time. To start using snippets, ensure you have the latest version of Erlang LS. Then, simply start typing snippet . A dropdown with all available snippets will appear, so you can select one. A few built-in snippets are available, ranging from a try catch construct to a receive after statement, from a record attribute to edoc blocks. Snippets contain placeholders , which can be used for easier navigation via the TAB key. They also have the concept of a variable , which gets expanded automatically when the snippet is selected. The syntax for snippets is described in detail here . Contributing snippets is trivial and does not require coding. Built-in snippets are stored in the Erlang LS priv directory. It is also possible to add custom snippets by dropping them into: ~/.config/erlang_ls/snippets This mechanism allows your organization to customize snippets, so they match specific coding styles and conventions. A custom snippet which has the same name as built-in one will take precedence, so the former will override the latter in the snippets dropdown. Enjoy!","title":"Snippets are here"},{"location":"articles/suggest-type-specs/","text":"Suggesting Type Specs Erlang is a strict, dynamically typed, functional programming language. When implementing an Erlang function, it is not required to include any explicit information about the types of the input parameters, nor of the return value of the function. While this can sometimes be seen as convenient, in the sense that it allows fast prototyping of a function, it has the heavy drawback that type errors can occur at runtime, when it is too late. Lack of type information can also make it harder to understand the purpose of a function, given its signature. In the Erlang ecosystem, a tool named dialyzer exists to help the programmer to identify software discrepancies such as type errors via a static analysis. While Dialyzer works by inferring type information using a technique based on success typings , it is possible to explicitly annotate an Erlang function with type information. Adding type specifications to a function is particularly useful for the programmer when reading and reasoning about code, since they give an overview of the function contract . Given the function sum/2 which computes the sum of two numbers : sum(A, B) -> A + B. We can annotate it with type specifications : -spec sum(number(), number()) -> number(). sum(A, B) -> A + B. For more information about type specifications and their syntax, please refer to the official reference manual . Type specifications can often be programmatically inferred. If we look again at the sum/2 function above, we can see that the two input values for the function ( A and B ) are passed straight away to the + operator. That implies that, for the sum/2 function not to fail, both A and B (and the return value of the function itself!) must be numbers . This is essentially how - well, in a very simplifyied way - a less known tool, named Typer , works under the hood to generate type specifications for functions which lack them. Erlang LS today leverages both Dialyzer and Typer to make it possible for the programmer to generate type specifications directly from the text editor. First Time Setup To do its job, Dialyzer (and therefore Erlang LS) makes use of a Persistent Lookup Table (a.k.a. PLT ). This table needs to be generated before you can use this feature in Erlang LS. Generating a PLT is a simple operation that can be achieved via: dialyzer --build_plt --apps erts kernel stdlib Where you can of course customize the provided list of applications. For more information about creating a PLT and how to later update it, please refer to the Dialyzer User Guide . Whenever a function lacks type specifications, you will see a Add spec code lens next to the function definition. By clicking on the lens (or by using a keyboard shortcut), Erlang LS will attempt at suggesting type specifications for your function. This is what the procedure looks like in Emacs: This feature is enabled by default in Erlang LS. Like for any other code lens , the feature can be disabled via the erlang_ls.config file, using the following configuration: lenses: disabled: - suggest-spec To make this possible, we had to fork the typer program from Erlang/OTP, mostly because the tool was designed as a separate Command Line utility and not to be invoked from Erlang code. This is something that should be easy to address in Erlang/OTP itself, avoiding the need of a fork in the future. There are a few other things to take into account when using this feature, most of which could be addressed in Typer itself: The function signatures do not include spaces after commas, making linters complain When producing records, the output is extremely verbose (containing types for all fields) and that should be simplified When user defined aliases exist for a given type, they should be used (this can be tricky to implement) Finally, other tools such as Gradualizer could be considered and eventually integrated in Erlang LS. For now, I hope you enjoy!","title":"Suggesting Type Specs"},{"location":"articles/suggest-type-specs/#suggesting-type-specs","text":"Erlang is a strict, dynamically typed, functional programming language. When implementing an Erlang function, it is not required to include any explicit information about the types of the input parameters, nor of the return value of the function. While this can sometimes be seen as convenient, in the sense that it allows fast prototyping of a function, it has the heavy drawback that type errors can occur at runtime, when it is too late. Lack of type information can also make it harder to understand the purpose of a function, given its signature. In the Erlang ecosystem, a tool named dialyzer exists to help the programmer to identify software discrepancies such as type errors via a static analysis. While Dialyzer works by inferring type information using a technique based on success typings , it is possible to explicitly annotate an Erlang function with type information. Adding type specifications to a function is particularly useful for the programmer when reading and reasoning about code, since they give an overview of the function contract . Given the function sum/2 which computes the sum of two numbers : sum(A, B) -> A + B. We can annotate it with type specifications : -spec sum(number(), number()) -> number(). sum(A, B) -> A + B. For more information about type specifications and their syntax, please refer to the official reference manual . Type specifications can often be programmatically inferred. If we look again at the sum/2 function above, we can see that the two input values for the function ( A and B ) are passed straight away to the + operator. That implies that, for the sum/2 function not to fail, both A and B (and the return value of the function itself!) must be numbers . This is essentially how - well, in a very simplifyied way - a less known tool, named Typer , works under the hood to generate type specifications for functions which lack them. Erlang LS today leverages both Dialyzer and Typer to make it possible for the programmer to generate type specifications directly from the text editor. First Time Setup To do its job, Dialyzer (and therefore Erlang LS) makes use of a Persistent Lookup Table (a.k.a. PLT ). This table needs to be generated before you can use this feature in Erlang LS. Generating a PLT is a simple operation that can be achieved via: dialyzer --build_plt --apps erts kernel stdlib Where you can of course customize the provided list of applications. For more information about creating a PLT and how to later update it, please refer to the Dialyzer User Guide . Whenever a function lacks type specifications, you will see a Add spec code lens next to the function definition. By clicking on the lens (or by using a keyboard shortcut), Erlang LS will attempt at suggesting type specifications for your function. This is what the procedure looks like in Emacs: This feature is enabled by default in Erlang LS. Like for any other code lens , the feature can be disabled via the erlang_ls.config file, using the following configuration: lenses: disabled: - suggest-spec To make this possible, we had to fork the typer program from Erlang/OTP, mostly because the tool was designed as a separate Command Line utility and not to be invoked from Erlang code. This is something that should be easy to address in Erlang/OTP itself, avoiding the need of a fork in the future. There are a few other things to take into account when using this feature, most of which could be addressed in Typer itself: The function signatures do not include spaces after commas, making linters complain When producing records, the output is extremely verbose (containing types for all fields) and that should be simplified When user defined aliases exist for a given type, they should be used (this can be tricky to implement) Finally, other tools such as Gradualizer could be considered and eventually integrated in Erlang LS. For now, I hope you enjoy!","title":"Suggesting Type Specs"},{"location":"articles/tutorial-code-lenses/","text":"How To: Code Lenses In our previous tutorial we learned how to implement a diagnostics backend for the Erlang Language Server. This time we will dig into the world of Code Lenses . The Goal Given an Erlang module containing a number of function defintions, we want to display the number of references to each function above its respective definition. Here is how the code lens will look like in VS Code . At the end of this tutorial you will: Know what a code lens is Learn how to implement a code lens in Erlang LS Move a step closer to becoming an Erlang LS contributor Without further ado, let's start. What is a Code Lens, anyway? A Code Lens is defined by Wade Anderson as: an actionable contextual information interspersed in your source code That's a very fancy way to say that a code lens is an arbitrary piece of text which appears in the IDE , next to your code. The text often provides insights about a portion of the code, as in the example we just saw above. Code lenses can also be actionable . The user can activate a lens by clicking on it or by using a keyboard shortcut, to perform an action. The triggered action can be anything. Here is an Emacs code lens which allows the user to execute a given Common Test testcase: Code lenses are contextual , meaning that they are aware of the surrounding context . In the above example, the Run test lens is aware of which specific testcase should be executed on click. Now that we understand what a code lens is, let's implement one in Erlang LS. Implementing a New Code Lens Backend Erlang LS provides a framework to make development of code lenses as simple as possible. To create our new code lens, the first thing we need to do is to decide a name for it and to create a new Erlang module implementing the els_code_lens behaviour. Let's call the new code lens function_references . -module(els_code_lens_function_references). -behaviour(els_code_lens). The els_code_lens behaviour requires three callback functions to be implemented: -callback is_default() -> boolean(). -callback pois(els_dt_document:item()) -> [poi()]. -callback command(els_dt_document:item(), poi(), state()) -> els_command:command(). We will see in a second what each callback function is supposed to do. For now, let's add the following exports to our els_code_lens_function_references module: -export([ is_default/0 , pois/1 , command/3 ]). Now we can focus on each individual callback function. The is_default/0 callback The is_default/0 callback is used to specify if the current backend should be enabled by default or not. In our case, we want the new backend to be enabled by default, so we say: is_default() -> true. Should the end user decide to disable this backend, she can just add to her erlang_ls.config the following option: lenses: disabled: function_references The pois/1 callback In Erlang LS jargon, POI stands for Point of Interest . The term refers to the interesting bits that are part of a code base. Points of Interest are indexed by Erlang LS and stored in an in-memory database. A POI could refer to a function definition , a macro definition , a record usage , you name it. Erlang LS provides a set of utilities that allow for easy search and manipulation of Points Of Interest . The pois/1 function takes a single argument, the current document . Its return value is the list of POIs for which the lens should be activated for. In our case, we want our lens to be visible next to each function definition . Therefore, we write: pois(Document) -> els_dt_document:pois(Document, [function]). The command/3 callback The last mandatory callback we need to implement is the command/3 one. The callback takes three arguments: the current Document , a specific POI and a State . For the sake of this tutorial, we will ignore the State and focus on the first two arguments only. The Command The function needs to return a command . A command is an LSP data structure which contains: A title - the text which is rendered next to each selected POI A CommandId - an identifier for the command that gets executed on click The CommandArgs - the list of arguments to pass to the command Erlang LS provides an helper function to create such a data structure: the els_command:make_command/3 function. Then, our command/3 function will look something like this: command(Document, POI, _State) -> Title = title(Document, POI), CommandId = command_id(), CommandArgs = command_args(), els_command:make_command(Title, CommandId, CommandArgs). We will now describe each paramater in detail and learn how to compute them, starting from the Title . The Title The Title is the text that we want to present in the text editor, next to our Point of Interest (a.k.a. the POI ). In our case, we want to display the following text: Used [N] times To be able to compute the number N , we need to know how many references to the current function are spread across our code base. We can therefore query the Erlang LS database via the els_dt_references:find_by_id/2 helper function: title(Document, POI) -> %% Extract the module name from the current document #{uri := Uri} = Document, M = els_uri:module(Uri), %% Extract the function name and arity from the current POI #{id := {F, A}} = POI, %% Query the Erlang LS DB for references to the current function {ok, References} = els_dt_references:find_by_id(function, {M, F, A}), %% Calculate the number of references N = length(References), %% Format the title for the code lens unicode:characters_to_binary(io_lib:format(\"Used ~p times\", [N])). The els_dt_references:find_by_id/2 function takes two arguments: the Kind of references we are looking for ( function in our case) and the fully qualified Id of the current Point of Interest . For a function definition, the fully qualified identifier is a {M, F, A} tuple, representing the Module , the Function Name and the Arity of our function. As you can see above, we can extract the module M from the Document and the F and A from the current POI . CommandId and CommandArgs The CommandId is an arbitrary identifier for the command we want to run when the user clicks on our code lens. In our case, this action will be a no-op , but we still need to pick a name for our command. Let's call it function-references : command_id() -> <<\"function-references\">>. Since our command will be a no-op (we do not want anything to happen if the user clicks on the lens), our command will not require any arguments: command_args() -> []. We are essentially done. Here is our full els_code_lens_function_references module, for completeness: -module(els_code_lens_function_references). -behaviour(els_code_lens). -export([ is_default/0 , pois/1 , command/3 ]). is_default() -> true. pois(Document) -> els_dt_document:pois(Document, [function]). command(Document, POI, _State) -> Title = title(Document, POI), CommandId = command_id(), CommandArgs = command_args(), els_command:make_command(Title, CommandId, CommandArgs). title(Document, POI) -> #{uri := Uri} = Document, M = els_uri:module(Uri), #{id := {F, A}} = POI, {ok, References} = els_dt_references:find_by_id(function, {M, F, A}), N = length(References), unicode:characters_to_binary(io_lib:format(\"Used ~p times\", [N])). command_id() -> <<\"function-references\">>. command_args() -> []. Registering the code lens There is one more thing that we need to do before we can use our new shiny code lens: we need to tell Erlang LS that it exists. That can be achieved by adding our new code lens to the list of available_lenses in the els_code_lens module: available_lenses() -> [ ... , <<\"function-references\">> ]. That's all. Adding tests Our code lens at this point should be functional, but we cannot be sure until we write a test for it! Erlang LS provides a testing framework which can be used for this purpose. In this section we will assume that you have a bit of familiarity with the Erlang LS testing framework already. If you would like a more gentle introduction to testing in Erlang LS , please refer to the previous Diagnostics Tutorial . Creating a test module Let's create a test module named code_lens_function_references within the code_navigation test application: $ cat apps/els_lsp/priv/code_navigation/src/code_lens_function_references.erl -module(code_lens_function_references). -export([ a/0 ]). -spec a() -> ok. a() -> b(), c(). -spec b() -> ok. b() -> c(). -spec c() -> ok. c() -> ok. Registering the new testing module Simply open the els_test_utils module and add the new module to the list of sources . This will ensure the new module is properly indexed and some helper functions are available for it. sources() -> [ ... , code_lens_function_references , ... ]. Writing a testcase Let's then open the els_code_lens_SUITE module and add a testcase, where we check whether the new code lens works as expected in the new module. function_references(Config) -> Uri = ?config(code_lens_function_references_uri, Config), #{result := Result} = els_client:document_codelens(Uri), Expected = [ lens(5, 0) # First lens on line 5, 0 references , lens(10, 1) # Second lens on line 10, 1 reference , lens(14, 2) # Third lens on line 14, 2 references ], ?assertEqual(Expected, Result), ok. In the above testcase, we are fetching the Uri of the newly added test module by leveraging the Erlang LS testing framework. We then use the els_client to invoke the document_codelens method for the given Uri and we finally ensure that we receive the expected list of code lenses. lens/2 is an auxiliary function which constructs the data structure expected by the LSP protocol as follows: lens(Line, Usages) -> Title = unicode:characters_to_binary( io_lib:format(\"Used ~p times\", [Usages])), #{ command => #{ arguments => [] , command => els_command:with_prefix(<<\"function-references\">>) , title => Title } , data => [] , range => #{ 'end' => #{character => 1, line => Line} , start => #{character => 0, line => Line} } }. Let's run the test and ensure it passes. $ rebar3 ct --suite apps/els_lsp/test/els_code_lens_SUITE --case function_references --group tcp [...] ===> Running Common Test suites... %%% els_code_lens_SUITE: . All 1 tests passed. It looks like we are done here. Optional Callbacks Even if they are not needed for this tutorial, it is worth mentioning that two more optional callback functions are available as part of the els_code_lens behaviour: -callback init(els_dt_document:item()) -> state(). -callback precondition(els_dt_document:item()) -> boolean(). Let's describe them for completeness. The init/1 callback The init/1 callback allows us to perform some computation once per file and to pass around the computed values in the form a State to subsequent callback functions (remember the State argument which we ignored in the command/3 callback?). This is used, for example, in the suggest_spec code lens to run TypEr once for each Erlang module and to still be able to display one lens for each function. The precondition/1 callback The precondition/1 callback allows us to only enable a given lens for a specific type of documents . For example, the following implementation enables the ct_run_test lens only for Common Test suites, identified by the presence of an include_lib directive for the ct.hrl file: precondition(Document) -> Includes = els_dt_document:pois(Document, [include_lib]), case [POI || #{id := \"common_test/include/ct.hrl\"} = POI <- Includes] of [] -> false; _ -> true end. Conclusion At this point you should be able to try out your new code lens. The above code lens is already available in Erlang LS. You can see the whole contribution at: https://github.com/erlang-ls/erlang_ls/pull/947 I hope this tutorial helped you to get a better understanding about code lenses in general and how to implement one in Erlang LS. Looking forward to the wonderful lenses you will implement!","title":"How To: Code Lenses"},{"location":"articles/tutorial-code-lenses/#how-to-code-lenses","text":"In our previous tutorial we learned how to implement a diagnostics backend for the Erlang Language Server. This time we will dig into the world of Code Lenses .","title":"How To: Code Lenses"},{"location":"articles/tutorial-code-lenses/#the-goal","text":"Given an Erlang module containing a number of function defintions, we want to display the number of references to each function above its respective definition. Here is how the code lens will look like in VS Code . At the end of this tutorial you will: Know what a code lens is Learn how to implement a code lens in Erlang LS Move a step closer to becoming an Erlang LS contributor Without further ado, let's start.","title":"The Goal"},{"location":"articles/tutorial-code-lenses/#what-is-a-code-lens-anyway","text":"A Code Lens is defined by Wade Anderson as: an actionable contextual information interspersed in your source code That's a very fancy way to say that a code lens is an arbitrary piece of text which appears in the IDE , next to your code. The text often provides insights about a portion of the code, as in the example we just saw above. Code lenses can also be actionable . The user can activate a lens by clicking on it or by using a keyboard shortcut, to perform an action. The triggered action can be anything. Here is an Emacs code lens which allows the user to execute a given Common Test testcase: Code lenses are contextual , meaning that they are aware of the surrounding context . In the above example, the Run test lens is aware of which specific testcase should be executed on click. Now that we understand what a code lens is, let's implement one in Erlang LS.","title":"What is a Code Lens, anyway?"},{"location":"articles/tutorial-code-lenses/#implementing-a-new-code-lens-backend","text":"Erlang LS provides a framework to make development of code lenses as simple as possible. To create our new code lens, the first thing we need to do is to decide a name for it and to create a new Erlang module implementing the els_code_lens behaviour. Let's call the new code lens function_references . -module(els_code_lens_function_references). -behaviour(els_code_lens). The els_code_lens behaviour requires three callback functions to be implemented: -callback is_default() -> boolean(). -callback pois(els_dt_document:item()) -> [poi()]. -callback command(els_dt_document:item(), poi(), state()) -> els_command:command(). We will see in a second what each callback function is supposed to do. For now, let's add the following exports to our els_code_lens_function_references module: -export([ is_default/0 , pois/1 , command/3 ]). Now we can focus on each individual callback function.","title":"Implementing a New Code Lens Backend"},{"location":"articles/tutorial-code-lenses/#the-is_default0-callback","text":"The is_default/0 callback is used to specify if the current backend should be enabled by default or not. In our case, we want the new backend to be enabled by default, so we say: is_default() -> true. Should the end user decide to disable this backend, she can just add to her erlang_ls.config the following option: lenses: disabled: function_references","title":"The is_default/0 callback"},{"location":"articles/tutorial-code-lenses/#the-pois1-callback","text":"In Erlang LS jargon, POI stands for Point of Interest . The term refers to the interesting bits that are part of a code base. Points of Interest are indexed by Erlang LS and stored in an in-memory database. A POI could refer to a function definition , a macro definition , a record usage , you name it. Erlang LS provides a set of utilities that allow for easy search and manipulation of Points Of Interest . The pois/1 function takes a single argument, the current document . Its return value is the list of POIs for which the lens should be activated for. In our case, we want our lens to be visible next to each function definition . Therefore, we write: pois(Document) -> els_dt_document:pois(Document, [function]).","title":"The pois/1 callback"},{"location":"articles/tutorial-code-lenses/#the-command3-callback","text":"The last mandatory callback we need to implement is the command/3 one. The callback takes three arguments: the current Document , a specific POI and a State . For the sake of this tutorial, we will ignore the State and focus on the first two arguments only.","title":"The command/3 callback"},{"location":"articles/tutorial-code-lenses/#the-command","text":"The function needs to return a command . A command is an LSP data structure which contains: A title - the text which is rendered next to each selected POI A CommandId - an identifier for the command that gets executed on click The CommandArgs - the list of arguments to pass to the command Erlang LS provides an helper function to create such a data structure: the els_command:make_command/3 function. Then, our command/3 function will look something like this: command(Document, POI, _State) -> Title = title(Document, POI), CommandId = command_id(), CommandArgs = command_args(), els_command:make_command(Title, CommandId, CommandArgs). We will now describe each paramater in detail and learn how to compute them, starting from the Title .","title":"The Command"},{"location":"articles/tutorial-code-lenses/#the-title","text":"The Title is the text that we want to present in the text editor, next to our Point of Interest (a.k.a. the POI ). In our case, we want to display the following text: Used [N] times To be able to compute the number N , we need to know how many references to the current function are spread across our code base. We can therefore query the Erlang LS database via the els_dt_references:find_by_id/2 helper function: title(Document, POI) -> %% Extract the module name from the current document #{uri := Uri} = Document, M = els_uri:module(Uri), %% Extract the function name and arity from the current POI #{id := {F, A}} = POI, %% Query the Erlang LS DB for references to the current function {ok, References} = els_dt_references:find_by_id(function, {M, F, A}), %% Calculate the number of references N = length(References), %% Format the title for the code lens unicode:characters_to_binary(io_lib:format(\"Used ~p times\", [N])). The els_dt_references:find_by_id/2 function takes two arguments: the Kind of references we are looking for ( function in our case) and the fully qualified Id of the current Point of Interest . For a function definition, the fully qualified identifier is a {M, F, A} tuple, representing the Module , the Function Name and the Arity of our function. As you can see above, we can extract the module M from the Document and the F and A from the current POI .","title":"The Title"},{"location":"articles/tutorial-code-lenses/#commandid-and-commandargs","text":"The CommandId is an arbitrary identifier for the command we want to run when the user clicks on our code lens. In our case, this action will be a no-op , but we still need to pick a name for our command. Let's call it function-references : command_id() -> <<\"function-references\">>. Since our command will be a no-op (we do not want anything to happen if the user clicks on the lens), our command will not require any arguments: command_args() -> []. We are essentially done. Here is our full els_code_lens_function_references module, for completeness: -module(els_code_lens_function_references). -behaviour(els_code_lens). -export([ is_default/0 , pois/1 , command/3 ]). is_default() -> true. pois(Document) -> els_dt_document:pois(Document, [function]). command(Document, POI, _State) -> Title = title(Document, POI), CommandId = command_id(), CommandArgs = command_args(), els_command:make_command(Title, CommandId, CommandArgs). title(Document, POI) -> #{uri := Uri} = Document, M = els_uri:module(Uri), #{id := {F, A}} = POI, {ok, References} = els_dt_references:find_by_id(function, {M, F, A}), N = length(References), unicode:characters_to_binary(io_lib:format(\"Used ~p times\", [N])). command_id() -> <<\"function-references\">>. command_args() -> [].","title":"CommandId and CommandArgs"},{"location":"articles/tutorial-code-lenses/#registering-the-code-lens","text":"There is one more thing that we need to do before we can use our new shiny code lens: we need to tell Erlang LS that it exists. That can be achieved by adding our new code lens to the list of available_lenses in the els_code_lens module: available_lenses() -> [ ... , <<\"function-references\">> ]. That's all.","title":"Registering the code lens"},{"location":"articles/tutorial-code-lenses/#adding-tests","text":"Our code lens at this point should be functional, but we cannot be sure until we write a test for it! Erlang LS provides a testing framework which can be used for this purpose. In this section we will assume that you have a bit of familiarity with the Erlang LS testing framework already. If you would like a more gentle introduction to testing in Erlang LS , please refer to the previous Diagnostics Tutorial .","title":"Adding tests"},{"location":"articles/tutorial-code-lenses/#creating-a-test-module","text":"Let's create a test module named code_lens_function_references within the code_navigation test application: $ cat apps/els_lsp/priv/code_navigation/src/code_lens_function_references.erl -module(code_lens_function_references). -export([ a/0 ]). -spec a() -> ok. a() -> b(), c(). -spec b() -> ok. b() -> c(). -spec c() -> ok. c() -> ok.","title":"Creating a test module"},{"location":"articles/tutorial-code-lenses/#registering-the-new-testing-module","text":"Simply open the els_test_utils module and add the new module to the list of sources . This will ensure the new module is properly indexed and some helper functions are available for it. sources() -> [ ... , code_lens_function_references , ... ].","title":"Registering the new testing module"},{"location":"articles/tutorial-code-lenses/#writing-a-testcase","text":"Let's then open the els_code_lens_SUITE module and add a testcase, where we check whether the new code lens works as expected in the new module. function_references(Config) -> Uri = ?config(code_lens_function_references_uri, Config), #{result := Result} = els_client:document_codelens(Uri), Expected = [ lens(5, 0) # First lens on line 5, 0 references , lens(10, 1) # Second lens on line 10, 1 reference , lens(14, 2) # Third lens on line 14, 2 references ], ?assertEqual(Expected, Result), ok. In the above testcase, we are fetching the Uri of the newly added test module by leveraging the Erlang LS testing framework. We then use the els_client to invoke the document_codelens method for the given Uri and we finally ensure that we receive the expected list of code lenses. lens/2 is an auxiliary function which constructs the data structure expected by the LSP protocol as follows: lens(Line, Usages) -> Title = unicode:characters_to_binary( io_lib:format(\"Used ~p times\", [Usages])), #{ command => #{ arguments => [] , command => els_command:with_prefix(<<\"function-references\">>) , title => Title } , data => [] , range => #{ 'end' => #{character => 1, line => Line} , start => #{character => 0, line => Line} } }. Let's run the test and ensure it passes. $ rebar3 ct --suite apps/els_lsp/test/els_code_lens_SUITE --case function_references --group tcp [...] ===> Running Common Test suites... %%% els_code_lens_SUITE: . All 1 tests passed. It looks like we are done here.","title":"Writing a testcase"},{"location":"articles/tutorial-code-lenses/#optional-callbacks","text":"Even if they are not needed for this tutorial, it is worth mentioning that two more optional callback functions are available as part of the els_code_lens behaviour: -callback init(els_dt_document:item()) -> state(). -callback precondition(els_dt_document:item()) -> boolean(). Let's describe them for completeness.","title":"Optional Callbacks"},{"location":"articles/tutorial-code-lenses/#the-init1-callback","text":"The init/1 callback allows us to perform some computation once per file and to pass around the computed values in the form a State to subsequent callback functions (remember the State argument which we ignored in the command/3 callback?). This is used, for example, in the suggest_spec code lens to run TypEr once for each Erlang module and to still be able to display one lens for each function.","title":"The init/1 callback"},{"location":"articles/tutorial-code-lenses/#the-precondition1-callback","text":"The precondition/1 callback allows us to only enable a given lens for a specific type of documents . For example, the following implementation enables the ct_run_test lens only for Common Test suites, identified by the presence of an include_lib directive for the ct.hrl file: precondition(Document) -> Includes = els_dt_document:pois(Document, [include_lib]), case [POI || #{id := \"common_test/include/ct.hrl\"} = POI <- Includes] of [] -> false; _ -> true end.","title":"The precondition/1 callback"},{"location":"articles/tutorial-code-lenses/#conclusion","text":"At this point you should be able to try out your new code lens. The above code lens is already available in Erlang LS. You can see the whole contribution at: https://github.com/erlang-ls/erlang_ls/pull/947 I hope this tutorial helped you to get a better understanding about code lenses in general and how to implement one in Erlang LS. Looking forward to the wonderful lenses you will implement!","title":"Conclusion"},{"location":"articles/tutorial-debugger/","text":"How To: Use the Debugger Erlang LS provides debugging functionalities via the Debug Adapter Protocol , in short DAP . Given the editor-agnostic nature of the protocol, debugging is available in all text editors and IDEs which support the DAP protocol. Here is what a debugging session looks like in Emacs: The current underlying implementation is based on the Erlang interpreter which comes with Erlang/OTP. Incidentally, the official OTP Debugger is also powered by the same interpreter. In this tutorial we will bootstrap a sample project and see how we can debug our code using Erlang LS. Install the debugger Debugging functionalities are provided in Erlang LS via a separate executable (an Erlang escript ) named els_dap . VS Code The executable is bundled with the Erlang LS extension, so it does not require any additional installation steps. You can configure the Erlang LS extension to use a custom version of the debugger by specifying a different DAP Path : Extension Settings > DAP Path Emacs If you are using Emacs, chances are that you are building Erlang LS from source. To produce the els_dap escript: rebar3 as dap escriptize Or simply: make You will then find the els_dap escript in: _build/dap/bin/els_dap Ensure the produced els_dap escript resides in a PATH known to Emacs. The official dap-mode package supports Erlang, so require both the package and the Erlang plugin: ( require 'dap-mode ) ( require 'dap-erlang ) You can refer to the official dap-mode documentation for more information on how to install and configure the dap-mode package and its plugins. Setup a sample project To showcase the Erlang LS debugger we will use the Hello World example from the Cowboy webserver. Let's start by cloning the project: git clone https://github.com/ninenines/cowboy.git cd cowboy/examples/hello_world The project uses the erlang.mk build system and the relx release assembler. To be able to use the debugger with our sample project we will need to apply two small modifications to the project: Include the Erlang debugger as a dependency Tell erlang.mk to symlink the hello_world application in the release To add the debugger as a dependency, add the following line to the project's Makefile just before the include ../../erlang.mk line: LOCAL_DEPS = debugger To symlink the application, add the following line to the relx.config file: { overrides , [{ hello_world , \"../hello_world\" }]}. We can now lunch our web server: make run The above should result in a new Erlang node running in the terminal, named hello_world_example@[HOSTNAME] . We should now be able to point our browser to http://localhost:8080 to see our glorious Hello world! string. Let's keep the server running. Open a new terminal and proceed with the following steps. Create a launch configuration We need to tell the debugger how to connect to the running node. We will do so via a launch configuration . About launch configurations Despite being a VS Code specific concept, launch configurations can now be used with multiple text editors and IDEs, including Emacs. VS Code Navigate to the Run and Debug panel and click on Create a launch.json file link and select the Erlang OTP Debugger option. This will create a file in .vscode/launch.json . Replace the content of the file with the following one: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Existing Erlang Node\" , \"type\" : \"erlang\" , \"request\" : \"attach\" , \"projectnode\" : \"hello_world_example\" , \"cookie\" : \"hello_world_example\" , \"timeout\" : 300 , \"cwd\" : \"${workspaceRoot}\" } ] } Emacs We need to create a file named launch.json in the top-level directory of the project. In our case, the file will reside in cowboy/examples/hello_world/launch.json : { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Existing Erlang Node\" , \"type\" : \"erlang\" , \"request\" : \"attach\" , \"projectnode\" : \"hello_world_example\" , \"cookie\" : \"hello_world_example\" , \"timeout\" : 300 } ] } Add a breakpoint VS Code Access the src/toppage_h.erl file and add a breakpoint by clicking next to the line number corresponding to the first line of the init/2 function body. Emacs Navigate to the src/toppage_h.erl , move to the first line of the init/2 function body and run: M-x dap-breakpoint-add Start a debugging session VS Code Select the Run and Debug panel, select Existing Erlang Node from the dropdown and press the play button: Open a new terminal and use the curl command to trigger our new breakpoint. curl -i http://localhost:8080 HTTP/1.1 200 OK content-length: 12 content-type: text/plain date: Fri, 09 Jul 2021 13 :35:01 GMT server: Cowboy Hello world! Execution will be paused on the breakpoint. You can then use the standard VS Code controls to control execution: On the left hand side it is possible to explore the call stack and the variable bindings. For example, we can incrementally expand the bindings for the Cowboy input request and verify the value for the User Agent header: The Debug Console at the bottom can be used as a REPL with the current variable bindings available: The Watch List on the left can be used to track the value of a specific variable (for example, the Opts variable): And the Debug Console to manipulate those values: VS Code offers extensive debugging functionalities. For more information please refer to the official VS Code documentation . Emacs Open the src/toppage_h.erl buffer and run: M-x dap-debug You will get prompted for a configuration template . Select Existing Erlang Node . Open a new terminal and use the curl command to trigger our new breakpoint. curl -i http://localhost:8080 HTTP/1.1 200 OK content-length: 12 content-type: text/plain date: Fri, 09 Jul 2021 13 :35:01 GMT server: Cowboy Hello world! Execution will be paused on the breakpoint. You can then use the standard Emacs controls to control execution: On the right hand side it is possible to explore the call stack and the variable bindings. For example, we can incrementally expand the bindings for the Cowboy input request and verify the value for the User Agent header: You can also open a REPL with the current variable bindings available: M-x dap-eval The dap-mode package offers extensive debugging functionalities. For more information please refer to the official documentation . Debugging and concurrency Due to the nature of Erlang processes, debugging a concurrent system could be tricky. As an example, a breakpoint could cause an internal timeout to occur and cause a crash as a consequence. Therefore, Erlang processes may require to be properly isolated or protected during a step-by-step debugging session. Special Breakpoint Types The DAP protocol describes a variety of breakpoint types which can be used in different situations: Conditional breakpoints Logpoints Hitpoints Conditional Breakpoints Conditional breakpoints are only triggered whenever a given condition evaluates to true . For example, we may want execution to break only when the value of the Host header passed by the client contains the string pigeon : VS Code To setup a conditional breakpoint, right-click next to a line number and select the Add a conditional breakpoint... option. Add the following expression : maps : get ( << \"host\" >> , maps : get ( headers , Req0 )) =:= << \"pigeon\" >> Emacs To add a conditional breakpoint, move to an existing breakpoint, then run: M-x dap-breakpoint-condition And add the following expression : maps : get ( << \"host\" >> , maps : get ( headers , Req0 )) =:= << \"pigeon\" >> With the above conditional breakpoint set, the following request will not cause execution to break: curl -i http://localhost:8080 But the following will: curl -H \"Host: pigeon\" -i http://localhost:8080 Logpoints Logpoints are a special type of breakpoint which do not cause execution to break, but they result in a log message to be printed out in the Debug Console . VS Code To log the Host header on every request, right-click next to the line number and select the Add logpoint... option. Add the following Log Message : maps:get ( << \"host\" >>, maps:get ( headers, Req0 )) Let's trigger a few requests with different (or default) host headers: curl -i http://localhost:8080 curl -H \"Host: pigeon\" -i http://localhost:8080 We can then follow the logpoints in the debug console: Emacs To log the Host header on every request, move to an existing breakpoint, then run: M-x dap-breakpoint-log-message Add the following Log Message : maps:get ( << \"host\" >>, maps:get ( headers, Req0 )) Let's trigger a few requests with different (or default) host headers: curl -i http://localhost:8080 curl -H \"Host: pigeon\" -i http://localhost:8080 To follow the logpoints , run: M-x dap-go-to-output-buffer Hitpoints Hitpoints are a special kind of breakpoint which are triggered every Nth time. VS Code Select an existing breakpoint and choose the Hit Count option from the dropdown. Specify a number N . The respective breakpoint will be triggered every Nth time. Emacs Navigate to an existing breakpoint. Run: M-x dap-breakpoint-hit-condition Specify a number N . The respective breakpoint will be triggered every Nth time. Troubleshooting If something does not work as expected, have a look to the Erlang LS DAP logs. They will most likely point you to the root cause of the issue. Logs are available at: [ USER_LOG_DIR ] / [ PROJECT_NAME ] /dap_server.log Where [USER_LOG_DIR] is the output of: filename : basedir ( user_log , \"els_dap\" ). For example, on Mac OS, the DAP logs for the hello_world project will be in: /Users/ [ USERNAME ] /Library/Logs/els_dap/hello_world/dap_server.log If the DAP logs do not help, feel free to reach out on GitHub or Slack . Happy debugging with Erlang LS!","title":"How To: Use the Debugger"},{"location":"articles/tutorial-debugger/#how-to-use-the-debugger","text":"Erlang LS provides debugging functionalities via the Debug Adapter Protocol , in short DAP . Given the editor-agnostic nature of the protocol, debugging is available in all text editors and IDEs which support the DAP protocol. Here is what a debugging session looks like in Emacs: The current underlying implementation is based on the Erlang interpreter which comes with Erlang/OTP. Incidentally, the official OTP Debugger is also powered by the same interpreter. In this tutorial we will bootstrap a sample project and see how we can debug our code using Erlang LS.","title":"How To: Use the Debugger"},{"location":"articles/tutorial-debugger/#install-the-debugger","text":"Debugging functionalities are provided in Erlang LS via a separate executable (an Erlang escript ) named els_dap . VS Code The executable is bundled with the Erlang LS extension, so it does not require any additional installation steps. You can configure the Erlang LS extension to use a custom version of the debugger by specifying a different DAP Path : Extension Settings > DAP Path Emacs If you are using Emacs, chances are that you are building Erlang LS from source. To produce the els_dap escript: rebar3 as dap escriptize Or simply: make You will then find the els_dap escript in: _build/dap/bin/els_dap Ensure the produced els_dap escript resides in a PATH known to Emacs. The official dap-mode package supports Erlang, so require both the package and the Erlang plugin: ( require 'dap-mode ) ( require 'dap-erlang ) You can refer to the official dap-mode documentation for more information on how to install and configure the dap-mode package and its plugins.","title":"Install the debugger"},{"location":"articles/tutorial-debugger/#setup-a-sample-project","text":"To showcase the Erlang LS debugger we will use the Hello World example from the Cowboy webserver. Let's start by cloning the project: git clone https://github.com/ninenines/cowboy.git cd cowboy/examples/hello_world The project uses the erlang.mk build system and the relx release assembler. To be able to use the debugger with our sample project we will need to apply two small modifications to the project: Include the Erlang debugger as a dependency Tell erlang.mk to symlink the hello_world application in the release To add the debugger as a dependency, add the following line to the project's Makefile just before the include ../../erlang.mk line: LOCAL_DEPS = debugger To symlink the application, add the following line to the relx.config file: { overrides , [{ hello_world , \"../hello_world\" }]}. We can now lunch our web server: make run The above should result in a new Erlang node running in the terminal, named hello_world_example@[HOSTNAME] . We should now be able to point our browser to http://localhost:8080 to see our glorious Hello world! string. Let's keep the server running. Open a new terminal and proceed with the following steps.","title":"Setup a sample project"},{"location":"articles/tutorial-debugger/#create-a-launch-configuration","text":"We need to tell the debugger how to connect to the running node. We will do so via a launch configuration . About launch configurations Despite being a VS Code specific concept, launch configurations can now be used with multiple text editors and IDEs, including Emacs. VS Code Navigate to the Run and Debug panel and click on Create a launch.json file link and select the Erlang OTP Debugger option. This will create a file in .vscode/launch.json . Replace the content of the file with the following one: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Existing Erlang Node\" , \"type\" : \"erlang\" , \"request\" : \"attach\" , \"projectnode\" : \"hello_world_example\" , \"cookie\" : \"hello_world_example\" , \"timeout\" : 300 , \"cwd\" : \"${workspaceRoot}\" } ] } Emacs We need to create a file named launch.json in the top-level directory of the project. In our case, the file will reside in cowboy/examples/hello_world/launch.json : { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Existing Erlang Node\" , \"type\" : \"erlang\" , \"request\" : \"attach\" , \"projectnode\" : \"hello_world_example\" , \"cookie\" : \"hello_world_example\" , \"timeout\" : 300 } ] }","title":"Create a launch configuration"},{"location":"articles/tutorial-debugger/#add-a-breakpoint","text":"VS Code Access the src/toppage_h.erl file and add a breakpoint by clicking next to the line number corresponding to the first line of the init/2 function body. Emacs Navigate to the src/toppage_h.erl , move to the first line of the init/2 function body and run: M-x dap-breakpoint-add","title":"Add a breakpoint"},{"location":"articles/tutorial-debugger/#start-a-debugging-session","text":"VS Code Select the Run and Debug panel, select Existing Erlang Node from the dropdown and press the play button: Open a new terminal and use the curl command to trigger our new breakpoint. curl -i http://localhost:8080 HTTP/1.1 200 OK content-length: 12 content-type: text/plain date: Fri, 09 Jul 2021 13 :35:01 GMT server: Cowboy Hello world! Execution will be paused on the breakpoint. You can then use the standard VS Code controls to control execution: On the left hand side it is possible to explore the call stack and the variable bindings. For example, we can incrementally expand the bindings for the Cowboy input request and verify the value for the User Agent header: The Debug Console at the bottom can be used as a REPL with the current variable bindings available: The Watch List on the left can be used to track the value of a specific variable (for example, the Opts variable): And the Debug Console to manipulate those values: VS Code offers extensive debugging functionalities. For more information please refer to the official VS Code documentation . Emacs Open the src/toppage_h.erl buffer and run: M-x dap-debug You will get prompted for a configuration template . Select Existing Erlang Node . Open a new terminal and use the curl command to trigger our new breakpoint. curl -i http://localhost:8080 HTTP/1.1 200 OK content-length: 12 content-type: text/plain date: Fri, 09 Jul 2021 13 :35:01 GMT server: Cowboy Hello world! Execution will be paused on the breakpoint. You can then use the standard Emacs controls to control execution: On the right hand side it is possible to explore the call stack and the variable bindings. For example, we can incrementally expand the bindings for the Cowboy input request and verify the value for the User Agent header: You can also open a REPL with the current variable bindings available: M-x dap-eval The dap-mode package offers extensive debugging functionalities. For more information please refer to the official documentation . Debugging and concurrency Due to the nature of Erlang processes, debugging a concurrent system could be tricky. As an example, a breakpoint could cause an internal timeout to occur and cause a crash as a consequence. Therefore, Erlang processes may require to be properly isolated or protected during a step-by-step debugging session.","title":"Start a debugging session"},{"location":"articles/tutorial-debugger/#special-breakpoint-types","text":"The DAP protocol describes a variety of breakpoint types which can be used in different situations: Conditional breakpoints Logpoints Hitpoints","title":"Special Breakpoint Types"},{"location":"articles/tutorial-debugger/#conditional-breakpoints","text":"Conditional breakpoints are only triggered whenever a given condition evaluates to true . For example, we may want execution to break only when the value of the Host header passed by the client contains the string pigeon : VS Code To setup a conditional breakpoint, right-click next to a line number and select the Add a conditional breakpoint... option. Add the following expression : maps : get ( << \"host\" >> , maps : get ( headers , Req0 )) =:= << \"pigeon\" >> Emacs To add a conditional breakpoint, move to an existing breakpoint, then run: M-x dap-breakpoint-condition And add the following expression : maps : get ( << \"host\" >> , maps : get ( headers , Req0 )) =:= << \"pigeon\" >> With the above conditional breakpoint set, the following request will not cause execution to break: curl -i http://localhost:8080 But the following will: curl -H \"Host: pigeon\" -i http://localhost:8080","title":"Conditional Breakpoints"},{"location":"articles/tutorial-debugger/#logpoints","text":"Logpoints are a special type of breakpoint which do not cause execution to break, but they result in a log message to be printed out in the Debug Console . VS Code To log the Host header on every request, right-click next to the line number and select the Add logpoint... option. Add the following Log Message : maps:get ( << \"host\" >>, maps:get ( headers, Req0 )) Let's trigger a few requests with different (or default) host headers: curl -i http://localhost:8080 curl -H \"Host: pigeon\" -i http://localhost:8080 We can then follow the logpoints in the debug console: Emacs To log the Host header on every request, move to an existing breakpoint, then run: M-x dap-breakpoint-log-message Add the following Log Message : maps:get ( << \"host\" >>, maps:get ( headers, Req0 )) Let's trigger a few requests with different (or default) host headers: curl -i http://localhost:8080 curl -H \"Host: pigeon\" -i http://localhost:8080 To follow the logpoints , run: M-x dap-go-to-output-buffer","title":"Logpoints"},{"location":"articles/tutorial-debugger/#hitpoints","text":"Hitpoints are a special kind of breakpoint which are triggered every Nth time. VS Code Select an existing breakpoint and choose the Hit Count option from the dropdown. Specify a number N . The respective breakpoint will be triggered every Nth time. Emacs Navigate to an existing breakpoint. Run: M-x dap-breakpoint-hit-condition Specify a number N . The respective breakpoint will be triggered every Nth time.","title":"Hitpoints"},{"location":"articles/tutorial-debugger/#troubleshooting","text":"If something does not work as expected, have a look to the Erlang LS DAP logs. They will most likely point you to the root cause of the issue. Logs are available at: [ USER_LOG_DIR ] / [ PROJECT_NAME ] /dap_server.log Where [USER_LOG_DIR] is the output of: filename : basedir ( user_log , \"els_dap\" ). For example, on Mac OS, the DAP logs for the hello_world project will be in: /Users/ [ USERNAME ] /Library/Logs/els_dap/hello_world/dap_server.log If the DAP logs do not help, feel free to reach out on GitHub or Slack . Happy debugging with Erlang LS!","title":"Troubleshooting"},{"location":"articles/tutorial-implementing-diagnostics/","text":"How To: Diagnostics A couple of days ago, NextRoll announced rebar3_hank , a \"powerful but simple tool to detect dead code around your Erlang codebase (and kill it with fire!)\" . In their original post the authors mentioned the overlap between rebar3_hank and some of the features provided by Erlang LS , such as detection of unused included files. Intrigued by the new tool, I decided to look deeper into it, to check whether rebar3_hank could be integrated with the diagnostics framework in Erlang LS, to avoid duplicated efforts within the Erlang Community. Both rebar3_hank and Erlang LS create diagnostics based on source code, but there are a few differences. For example, rebar3_hank acts on a project's code base as a whole, while Erlang LS operates on individual Erlang modules and their strict dependencies. Also, rebar3_hank is intended to be used as a CLI via a rebar3 plugin, while Erlang LS is a server which integrates with your IDE via the LSP protocol. It was immediately clear that an integration between both tools would require a certain degree of refactoring. The ideas of rebar3_hank were quite interesting, though, and most of them would be easily implementable in Erlang LS. So, I decided to port one of them, detection of unused macros , and to take this opportunity to explain the process of contributing a new diagnostics backend to Erlang LS. If you always wanted to contribute to Erlang LS, but you didn't know where to start, this post is for you. Let's start. The goal Given an Erlang module, we would like to be notified with a warning if a macro is defined, but not used. How can we make it happen? Adding a New Diagnostics Backend The first thing we need to do is to define a new Erlang module which implements the els_diagnostics behaviour. By convention, all diagnostics modules are named els_[BACKEND]_diagnostics.erl where [BACKEND] , in our case, will be unused_macros . So, the final name of the module will be els_unused_macros_diagnostics.erl . Let's open a new text file and add the following: -module(els_unused_macros_diagnostics). -behaviour(els_diagnostics). The els_diagnostics behaviour requires three callback functions to be implemented: -callback is_default() -> boolean(). -callback source() -> binary(). -callback run(uri()) -> [diagnostic()]. So let's add the following exports to the module. We will implement all functions in a second. -export([ is_default/0 , source/0 , run/1 ]). The is_default/0 callback The is_default/0 callback is used to specify if the current backend should be enabled by default or not. In our case, we want the new backend to be enabled by default, so we say: is_default() -> true. Should the end user decide to disable this backend, she can just add to her erlang_ls.config the following option: diagnostics: disabled: unused_macros The sources/0 callback Let's now implement our second callback function, source/0 . This function returns the human-friendly name for the backend, which is rendered by the IDE (see the UnusedMacros text in the above screenshot): source() -> <<\"UnusedMacros\">>. The run/1 function The last callback function we need to implement is where the interesting stuff happens. The run/1 function takes a single parameter, the Uri of the Erlang module for which diagnostics are run. By default, diagnostics are calculated OnOpen (when the module is firstly accessed in the IDE) and OnSave (whenever the module is saved from the IDE). The function returns a list of diagnostics for the module which will be rendered by the IDE, in a format specified by the LSP protocol . Diagnostics can be of four types: Hint Info Warning Error For the time being, let's return an empty list. run(_Uri) -> []. Registering the backend There's one more thing we need to do before we can use our backend in Erlang LS. We need to register it among the available backends. We can do this by adding an entry to the list of available diagnostics in the els_diagnostics module: available_diagnostics() -> [ <<\"compiler\">> , <<\"crossref\">> , <<\"dialyzer\">> , <<\"elvis\">> , <<\"unused_includes\">> , <<\"unused_macros\">> %% Here is our new shiny diagnostics backend! ]. Using a Test-Driven-Development (TDD) approach At this point, we could jump in and start implementing the body of our run/1 function. Then, to try if things are working as expected, we could: Rebuild our version of Erlang LS as an escript Open a new file in our IDE Restart Erlang LS Add an unused macro to our new file Save the file Ensure that a warning is produced on save Check Erlang LS logs to see why things don't work the way we expect Rinse and repeat This approach may even work, but it would slow down our feedback loop drastically and it would make the whole experience of contributing to Erlang LS painful. Luckily, there's a better way: starting with a test case. After all, if we are planning to contribute our new backend, we will be required to add a test case anyway. How do we implement a test case for such a feature, though? That sounds like a lot of work and we don't know where to start. Here is where the Erlang LS testing framework comes into play. The first thing we need to do is to add a minimal example to the Erlang LS test application (which for historical reasons is named code_navigation and should be renamed). You can find it in the priv directory of the project. Our minimal example could look like this: $ cat priv/code_navigation/src/diagnostics_unused_macros.erl -module(diagnostics_unused_macros). -export([main/0]). -define(USED_MACRO, used_macro). -define(UNUSED_MACRO, unused_macro). main() -> ?USED_MACRO. In the above code, we define two macros and we use only one of them. We therefore expect a warning on line 6 for the UNUSED_MACRO . We also need to register our minimal example into the Erlang LS testing framework. For that, we add a line to the list of sources in the els_test_utils module: sources() -> [ ... , diagnostics_unused_macros , ... ] Now, we can focus on the actual test case. Since it's a diagnostics test, we can extend the already existing els_diagnostics_SUITE module. The test suite leverages the Common Test framework in Erlang/OTP, so please refer to the official documentation if you are not familiar with it. First, we export the new testcase, which we call unused_macros : -export([ ... , unused_macros/1 . ... ]) Then, we can implement the body of our new testcase: unused_macros(Config) -> Uri = ?config(diagnostics_unused_macros_uri, Config), els_mock_diagnostics:subscribe(), ok = els_client:did_save(Uri), Diagnostics = els_mock_diagnostics:wait_until_complete(), Expected = [ #{ message => <<\"Unused macro: UNUSED_MACRO\">> , range => #{ 'end' => #{ character => 20 , line => 5 } , start => #{ character => 8 , line => 5 } } , severity => ?DIAGNOSTIC_WARNING , source => <<\"UnusedMacros\">> } ], ?assertEqual(Expected, Diagnostics), ok. Lot of things are happening here, so let's go through the code together, starting from the beginning: Uri = ?config(diagnostics_unused_macros_uri, Config), Here we fetch the Uri of the Erlang module containing our minimal example from the Common Test Config . This feels a bit magic, since we never populated that variable anywhere. What's going on? Remember that we registered our new testing module in the sources/1 function above? That caused the Erlang LS testing framework not just to index that file, but also to create a couple of handy variables which can be used when writing test cases. [MODULE_NAME]_uri is one of these variables. Another one is [MODULE_NAME]_text , which contains the actual source code of the module. But let's continue with our testcase for now: els_mock_diagnostics:subscribe(), Since we want to test a new diagnostics backend, we subscribe to the stream of diagnostics , so that we can intercept and validate them. Again, we use a utility function which the Erlang LS testing framework provides. ok = els_client:did_save(Uri), Diagnostics = els_mock_diagnostics:wait_until_complete(), We then simulate an IDE saving the file and wait until the diagnostics (which are calculated asynchronously) are completed. Expected = [ #{ message => <<\"Unused macro: UNUSED_MACRO\">> , range => #{ 'end' => #{ character => 20 , line => 5 } , start => #{ character => 8 , line => 5 } } , severity => ?DIAGNOSTIC_WARNING , source => <<\"UnusedMacros\">> } ], ?assertEqual(Expected, Diagnostics), ok. Here we verify that a warning message is generated by our backend (notice the source attribute). The warning message is expected on line 6, between characters 8 and 20 (which correspond to the location of the macro name ). The ?DIAGNOSTIC_WARNING macro is defined in the erlang_ls.hrl header file, so let's include it below the export list: -include(\"erlang_ls.hrl\"). Let's now execute our test case and check the result. Notice how we need to specify a group for the testcase, since all Erlang LS tests can be run for the two LSP supported transports ( TCP and stdio ). $ rebar3 ct --suite els_diagnostics_SUITE --case unused_macros --group tcp ===> Verifying dependencies... ===> Analyzing applications... ===> Compiling erlang_ls ===> Running Common Test suites... %%% els_diagnostics_SUITE: [...] expected: [#{message => <<\"Unused macro: UNUSED_MACRO\">>, range => #{'end' => #{character => 20,line => 5}, start => #{character => 8,line => 5}}, severity => 2,source => <<\"UnusedMacros\">>}] got: [] line: 582 Not surpringly, the testcase fails, since we haven't implemented our run/1 function yet, but we are returning an hard-coded empty list. Let's fix that now. Looking for Unused Macros We can finally jump to interesting bit of this tutorial, implementing a detection mechanism for unused macros. As usual, let's first look at the whole code and then explain its behaviour. run(Uri) -> {ok, [Document]} = els_dt_document:lookup(Uri), UnusedMacros = find_unused_macros(Document), [make_diagnostic(Macro) || Macro <- UnusedMacros]. First, we query the Erlang LS database by Uri . Then, we invoke the find_unused_macros/1 function - which we still need to implement - on the returned document . For each identified Macro , we produce a diagnostic , in the format expected by the LSP protocol. Again, we still need to implement our make_diagnostic/1 function. Let's now focus on the find_unused_macros/1 function. The goal of the function is to identify unused macros within a given document : find_unused_macros(Document) -> Definitions = els_dt_document:pois(Document, [define]), Usages = els_dt_document:pois(Document, [macro]), UsagesIds = [Id || #{id := Id} <- Usages], [POI || #{id := Id} = POI <- Definitions, not lists:member(Id, UsagesIds)]. Again, lot of things happening here, so let's go through the code line by line. First, we identify all the macro definitions, identified by the define key: Definitions = els_dt_document:pois(Document, [define]), Then, we identify all the macro usages, identifie by the macro key: Usages = els_dt_document:pois(Document, [macro]), You can refer to the els_parser module in Erlang LS for details about POIs ( Points of Interests ) and available keys. For each macro usage, we extract the respective id and we return the list of macro definitions which do not have a corresponding usage: UsagesIds = [Id || #{id := Id} <- Usages], [POI || #{id := Id} = POI <- Definitions, not lists:member(Id, UsagesIds)]. The last missing bit is the make_diagnostic/1 function, which will convert each POI into a diagnostic : make_diagnostic(#{id := Id, range := POIRange} = _POI) -> Range = els_protocol:range(POIRange), MacroName = atom_to_binary(Id, utf8), Message = <<\"Unused macro: \", MacroName/binary>>, Severity = ?DIAGNOSTIC_WARNING, Source = source(), els_diagnostics:make_diagnostic(Range, Message, Severity, Source). This function is essentially a wrapper around around the utility function els_diagnostics:make_diagnostic/4 . Let's analyze it in detail. Range = els_protocol:range(POIRange), Here we convert the range of the POI (the unused macro definition) in the format required by the LSP protocol, using a helper function provided by Erlang LS. MacroName = atom_to_binary(Id, utf8), Message = <<\"Unused macro: \", MacroName/binary>>, We then build the diagnostic message using the id (the name) of the offending macro. Severity = ?DIAGNOSTIC_WARNING, We specify warning as the severity of the message. Source = source(), We invoke the source/0 function to specify the source of the diagnostic (for rendering purposes in the IDE). els_diagnostics:make_diagnostic(Range, Message, Severity, Source). We finally invoke the els_diagnostics:make_diagnostic/4 function with the constructed arguments to produce a diagnostic . That should be it. Let's try to execute the testcase again: $ rebar3 ct --suite els_diagnostics_SUITE --case unused_macros --group tcp ===> Verifying dependencies... ===> Analyzing applications... ===> Compiling erlang_ls ===> Running Common Test suites... %%% els_diagnostics_SUITE: All 1 tests passed. Success! Tests now pass and we are able to identify unused macros in Erlang LS! The Complete Backend Here is the full implementation of the backend, for reference: -module(els_unused_macros_diagnostics). -behaviour(els_diagnostics). -export([ is_default/0 , source/0 , run/1 ]). -include(\"erlang_ls.hrl\"). is_default() -> true. source() -> <<\"UnusedMacros\">>. run(Uri) -> {ok, [Document]} = els_dt_document:lookup(Uri), UnusedMacros = find_unused_macros(Document), [make_diagnostic(Macro) || Macro <- UnusedMacros]. find_unused_macros(Document) -> Definitions = els_dt_document:pois(Document, [define]), Usages = els_dt_document:pois(Document, [macro]), UsagesIds = [Id || #{id := Id} <- Usages], [POI || #{id := Id} = POI <- Definitions, not lists:member(Id, UsagesIds)]. make_diagnostic(#{id := Id, range := POIRange} = _POI) -> Range = els_protocol:range(POIRange), MacroName = atom_to_binary(Id, utf8), Message = <<\"Unused macro: \", MacroName/binary>>, Severity = ?DIAGNOSTIC_WARNING, Source = source(), els_diagnostics:make_diagnostic(Range, Message, Severity, Source). Of course, the implementation above is quite minimalistic and could be improved in many ways, but at this point you should get the idea of what it means to implement a new diagnostics backend for Erlang LS. Conclusion The above backend is already integrated in Erlang LS, but as an opt-in backend. You can see the whole contribution at: https://github.com/erlang-ls/erlang_ls/pull/867/files Contributing to an open source can be a daunting experience, especially when you do not have an infinite amount of time available. I hope that this little tutorial can help you in that direction and I'm looking forward to the brilliant things that you can contribute to Erlang LS. Have fun!","title":"How To: Diagnostics"},{"location":"articles/tutorial-implementing-diagnostics/#how-to-diagnostics","text":"A couple of days ago, NextRoll announced rebar3_hank , a \"powerful but simple tool to detect dead code around your Erlang codebase (and kill it with fire!)\" . In their original post the authors mentioned the overlap between rebar3_hank and some of the features provided by Erlang LS , such as detection of unused included files. Intrigued by the new tool, I decided to look deeper into it, to check whether rebar3_hank could be integrated with the diagnostics framework in Erlang LS, to avoid duplicated efforts within the Erlang Community. Both rebar3_hank and Erlang LS create diagnostics based on source code, but there are a few differences. For example, rebar3_hank acts on a project's code base as a whole, while Erlang LS operates on individual Erlang modules and their strict dependencies. Also, rebar3_hank is intended to be used as a CLI via a rebar3 plugin, while Erlang LS is a server which integrates with your IDE via the LSP protocol. It was immediately clear that an integration between both tools would require a certain degree of refactoring. The ideas of rebar3_hank were quite interesting, though, and most of them would be easily implementable in Erlang LS. So, I decided to port one of them, detection of unused macros , and to take this opportunity to explain the process of contributing a new diagnostics backend to Erlang LS. If you always wanted to contribute to Erlang LS, but you didn't know where to start, this post is for you. Let's start.","title":"How To: Diagnostics"},{"location":"articles/tutorial-implementing-diagnostics/#the-goal","text":"Given an Erlang module, we would like to be notified with a warning if a macro is defined, but not used. How can we make it happen?","title":"The goal"},{"location":"articles/tutorial-implementing-diagnostics/#adding-a-new-diagnostics-backend","text":"The first thing we need to do is to define a new Erlang module which implements the els_diagnostics behaviour. By convention, all diagnostics modules are named els_[BACKEND]_diagnostics.erl where [BACKEND] , in our case, will be unused_macros . So, the final name of the module will be els_unused_macros_diagnostics.erl . Let's open a new text file and add the following: -module(els_unused_macros_diagnostics). -behaviour(els_diagnostics). The els_diagnostics behaviour requires three callback functions to be implemented: -callback is_default() -> boolean(). -callback source() -> binary(). -callback run(uri()) -> [diagnostic()]. So let's add the following exports to the module. We will implement all functions in a second. -export([ is_default/0 , source/0 , run/1 ]).","title":"Adding a New Diagnostics Backend"},{"location":"articles/tutorial-implementing-diagnostics/#the-is_default0-callback","text":"The is_default/0 callback is used to specify if the current backend should be enabled by default or not. In our case, we want the new backend to be enabled by default, so we say: is_default() -> true. Should the end user decide to disable this backend, she can just add to her erlang_ls.config the following option: diagnostics: disabled: unused_macros","title":"The is_default/0 callback"},{"location":"articles/tutorial-implementing-diagnostics/#the-sources0-callback","text":"Let's now implement our second callback function, source/0 . This function returns the human-friendly name for the backend, which is rendered by the IDE (see the UnusedMacros text in the above screenshot): source() -> <<\"UnusedMacros\">>.","title":"The sources/0 callback"},{"location":"articles/tutorial-implementing-diagnostics/#the-run1-function","text":"The last callback function we need to implement is where the interesting stuff happens. The run/1 function takes a single parameter, the Uri of the Erlang module for which diagnostics are run. By default, diagnostics are calculated OnOpen (when the module is firstly accessed in the IDE) and OnSave (whenever the module is saved from the IDE). The function returns a list of diagnostics for the module which will be rendered by the IDE, in a format specified by the LSP protocol . Diagnostics can be of four types: Hint Info Warning Error For the time being, let's return an empty list. run(_Uri) -> [].","title":"The run/1 function"},{"location":"articles/tutorial-implementing-diagnostics/#registering-the-backend","text":"There's one more thing we need to do before we can use our backend in Erlang LS. We need to register it among the available backends. We can do this by adding an entry to the list of available diagnostics in the els_diagnostics module: available_diagnostics() -> [ <<\"compiler\">> , <<\"crossref\">> , <<\"dialyzer\">> , <<\"elvis\">> , <<\"unused_includes\">> , <<\"unused_macros\">> %% Here is our new shiny diagnostics backend! ].","title":"Registering the backend"},{"location":"articles/tutorial-implementing-diagnostics/#using-a-test-driven-development-tdd-approach","text":"At this point, we could jump in and start implementing the body of our run/1 function. Then, to try if things are working as expected, we could: Rebuild our version of Erlang LS as an escript Open a new file in our IDE Restart Erlang LS Add an unused macro to our new file Save the file Ensure that a warning is produced on save Check Erlang LS logs to see why things don't work the way we expect Rinse and repeat This approach may even work, but it would slow down our feedback loop drastically and it would make the whole experience of contributing to Erlang LS painful. Luckily, there's a better way: starting with a test case. After all, if we are planning to contribute our new backend, we will be required to add a test case anyway. How do we implement a test case for such a feature, though? That sounds like a lot of work and we don't know where to start. Here is where the Erlang LS testing framework comes into play. The first thing we need to do is to add a minimal example to the Erlang LS test application (which for historical reasons is named code_navigation and should be renamed). You can find it in the priv directory of the project. Our minimal example could look like this: $ cat priv/code_navigation/src/diagnostics_unused_macros.erl -module(diagnostics_unused_macros). -export([main/0]). -define(USED_MACRO, used_macro). -define(UNUSED_MACRO, unused_macro). main() -> ?USED_MACRO. In the above code, we define two macros and we use only one of them. We therefore expect a warning on line 6 for the UNUSED_MACRO . We also need to register our minimal example into the Erlang LS testing framework. For that, we add a line to the list of sources in the els_test_utils module: sources() -> [ ... , diagnostics_unused_macros , ... ] Now, we can focus on the actual test case. Since it's a diagnostics test, we can extend the already existing els_diagnostics_SUITE module. The test suite leverages the Common Test framework in Erlang/OTP, so please refer to the official documentation if you are not familiar with it. First, we export the new testcase, which we call unused_macros : -export([ ... , unused_macros/1 . ... ]) Then, we can implement the body of our new testcase: unused_macros(Config) -> Uri = ?config(diagnostics_unused_macros_uri, Config), els_mock_diagnostics:subscribe(), ok = els_client:did_save(Uri), Diagnostics = els_mock_diagnostics:wait_until_complete(), Expected = [ #{ message => <<\"Unused macro: UNUSED_MACRO\">> , range => #{ 'end' => #{ character => 20 , line => 5 } , start => #{ character => 8 , line => 5 } } , severity => ?DIAGNOSTIC_WARNING , source => <<\"UnusedMacros\">> } ], ?assertEqual(Expected, Diagnostics), ok. Lot of things are happening here, so let's go through the code together, starting from the beginning: Uri = ?config(diagnostics_unused_macros_uri, Config), Here we fetch the Uri of the Erlang module containing our minimal example from the Common Test Config . This feels a bit magic, since we never populated that variable anywhere. What's going on? Remember that we registered our new testing module in the sources/1 function above? That caused the Erlang LS testing framework not just to index that file, but also to create a couple of handy variables which can be used when writing test cases. [MODULE_NAME]_uri is one of these variables. Another one is [MODULE_NAME]_text , which contains the actual source code of the module. But let's continue with our testcase for now: els_mock_diagnostics:subscribe(), Since we want to test a new diagnostics backend, we subscribe to the stream of diagnostics , so that we can intercept and validate them. Again, we use a utility function which the Erlang LS testing framework provides. ok = els_client:did_save(Uri), Diagnostics = els_mock_diagnostics:wait_until_complete(), We then simulate an IDE saving the file and wait until the diagnostics (which are calculated asynchronously) are completed. Expected = [ #{ message => <<\"Unused macro: UNUSED_MACRO\">> , range => #{ 'end' => #{ character => 20 , line => 5 } , start => #{ character => 8 , line => 5 } } , severity => ?DIAGNOSTIC_WARNING , source => <<\"UnusedMacros\">> } ], ?assertEqual(Expected, Diagnostics), ok. Here we verify that a warning message is generated by our backend (notice the source attribute). The warning message is expected on line 6, between characters 8 and 20 (which correspond to the location of the macro name ). The ?DIAGNOSTIC_WARNING macro is defined in the erlang_ls.hrl header file, so let's include it below the export list: -include(\"erlang_ls.hrl\"). Let's now execute our test case and check the result. Notice how we need to specify a group for the testcase, since all Erlang LS tests can be run for the two LSP supported transports ( TCP and stdio ). $ rebar3 ct --suite els_diagnostics_SUITE --case unused_macros --group tcp ===> Verifying dependencies... ===> Analyzing applications... ===> Compiling erlang_ls ===> Running Common Test suites... %%% els_diagnostics_SUITE: [...] expected: [#{message => <<\"Unused macro: UNUSED_MACRO\">>, range => #{'end' => #{character => 20,line => 5}, start => #{character => 8,line => 5}}, severity => 2,source => <<\"UnusedMacros\">>}] got: [] line: 582 Not surpringly, the testcase fails, since we haven't implemented our run/1 function yet, but we are returning an hard-coded empty list. Let's fix that now.","title":"Using a Test-Driven-Development (TDD) approach"},{"location":"articles/tutorial-implementing-diagnostics/#looking-for-unused-macros","text":"We can finally jump to interesting bit of this tutorial, implementing a detection mechanism for unused macros. As usual, let's first look at the whole code and then explain its behaviour. run(Uri) -> {ok, [Document]} = els_dt_document:lookup(Uri), UnusedMacros = find_unused_macros(Document), [make_diagnostic(Macro) || Macro <- UnusedMacros]. First, we query the Erlang LS database by Uri . Then, we invoke the find_unused_macros/1 function - which we still need to implement - on the returned document . For each identified Macro , we produce a diagnostic , in the format expected by the LSP protocol. Again, we still need to implement our make_diagnostic/1 function. Let's now focus on the find_unused_macros/1 function. The goal of the function is to identify unused macros within a given document : find_unused_macros(Document) -> Definitions = els_dt_document:pois(Document, [define]), Usages = els_dt_document:pois(Document, [macro]), UsagesIds = [Id || #{id := Id} <- Usages], [POI || #{id := Id} = POI <- Definitions, not lists:member(Id, UsagesIds)]. Again, lot of things happening here, so let's go through the code line by line. First, we identify all the macro definitions, identified by the define key: Definitions = els_dt_document:pois(Document, [define]), Then, we identify all the macro usages, identifie by the macro key: Usages = els_dt_document:pois(Document, [macro]), You can refer to the els_parser module in Erlang LS for details about POIs ( Points of Interests ) and available keys. For each macro usage, we extract the respective id and we return the list of macro definitions which do not have a corresponding usage: UsagesIds = [Id || #{id := Id} <- Usages], [POI || #{id := Id} = POI <- Definitions, not lists:member(Id, UsagesIds)]. The last missing bit is the make_diagnostic/1 function, which will convert each POI into a diagnostic : make_diagnostic(#{id := Id, range := POIRange} = _POI) -> Range = els_protocol:range(POIRange), MacroName = atom_to_binary(Id, utf8), Message = <<\"Unused macro: \", MacroName/binary>>, Severity = ?DIAGNOSTIC_WARNING, Source = source(), els_diagnostics:make_diagnostic(Range, Message, Severity, Source). This function is essentially a wrapper around around the utility function els_diagnostics:make_diagnostic/4 . Let's analyze it in detail. Range = els_protocol:range(POIRange), Here we convert the range of the POI (the unused macro definition) in the format required by the LSP protocol, using a helper function provided by Erlang LS. MacroName = atom_to_binary(Id, utf8), Message = <<\"Unused macro: \", MacroName/binary>>, We then build the diagnostic message using the id (the name) of the offending macro. Severity = ?DIAGNOSTIC_WARNING, We specify warning as the severity of the message. Source = source(), We invoke the source/0 function to specify the source of the diagnostic (for rendering purposes in the IDE). els_diagnostics:make_diagnostic(Range, Message, Severity, Source). We finally invoke the els_diagnostics:make_diagnostic/4 function with the constructed arguments to produce a diagnostic . That should be it. Let's try to execute the testcase again: $ rebar3 ct --suite els_diagnostics_SUITE --case unused_macros --group tcp ===> Verifying dependencies... ===> Analyzing applications... ===> Compiling erlang_ls ===> Running Common Test suites... %%% els_diagnostics_SUITE: All 1 tests passed. Success! Tests now pass and we are able to identify unused macros in Erlang LS!","title":"Looking for Unused Macros"},{"location":"articles/tutorial-implementing-diagnostics/#the-complete-backend","text":"Here is the full implementation of the backend, for reference: -module(els_unused_macros_diagnostics). -behaviour(els_diagnostics). -export([ is_default/0 , source/0 , run/1 ]). -include(\"erlang_ls.hrl\"). is_default() -> true. source() -> <<\"UnusedMacros\">>. run(Uri) -> {ok, [Document]} = els_dt_document:lookup(Uri), UnusedMacros = find_unused_macros(Document), [make_diagnostic(Macro) || Macro <- UnusedMacros]. find_unused_macros(Document) -> Definitions = els_dt_document:pois(Document, [define]), Usages = els_dt_document:pois(Document, [macro]), UsagesIds = [Id || #{id := Id} <- Usages], [POI || #{id := Id} = POI <- Definitions, not lists:member(Id, UsagesIds)]. make_diagnostic(#{id := Id, range := POIRange} = _POI) -> Range = els_protocol:range(POIRange), MacroName = atom_to_binary(Id, utf8), Message = <<\"Unused macro: \", MacroName/binary>>, Severity = ?DIAGNOSTIC_WARNING, Source = source(), els_diagnostics:make_diagnostic(Range, Message, Severity, Source). Of course, the implementation above is quite minimalistic and could be improved in many ways, but at this point you should get the idea of what it means to implement a new diagnostics backend for Erlang LS.","title":"The Complete Backend"},{"location":"articles/tutorial-implementing-diagnostics/#conclusion","text":"The above backend is already integrated in Erlang LS, but as an opt-in backend. You can see the whole contribution at: https://github.com/erlang-ls/erlang_ls/pull/867/files Contributing to an open source can be a daunting experience, especially when you do not have an infinite amount of time available. I hope that this little tutorial can help you in that direction and I'm looking forward to the brilliant things that you can contribute to Erlang LS. Have fun!","title":"Conclusion"},{"location":"getting-started/emacs/","text":"Emacs Setup The official lsp-mode package includes a client for the Erlang Language Server. Here you can find a sample Emacs configuration file which installs and configures all packages required to get all of the Erlang LS features working. Use this configuration file as a starting point for your Erlang LS Emacs configuration. Whenever opening a project for the first time, you will be prompted by emacs-lsp to select the correct project root. In that occasion, you also have the opportunity to blacklist projects. Information about projects is stored in a file pointed by the lsp-session-file variable. Its default location is ~/.emacs.d/.lsp-session-v1 . You may need to prune or amend this file if you change your mind about blacklisting a project or if you erroneously select a project root. For more information about the lsp-session-file and emacs-lsp in general, please refer to the official documentation . Remember that the Erlang Language Server requires Erlang/OTP 21 or higher to run, so ensure that OTP 21+ is available in your PATH . This can be achieved, for example, by using the exec-path-from-shell Emacs package. Restarting the language server You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so: M-x lsp-workspace-restart Troubleshooting If things do not work as expected, we advise you to start Emacs with only the configuration from the provided sample file, using the following command: emacs -q -l [PATH-TO-ERLANG-LS]/misc/dotemacs This will remove from the equation potential incompatibilities with other packages or configurations that you may have on your workstation and that could conflict with Erlang LS. To be sure that you don't have outdated or incompatible packages installed, you may also want to rename your ~/.emacs.d directory while you are troubleshooting your Erlang LS Emacs setup. Also, ensure that Erlang (i.e. erl , escript and friends) and the erlang_ls executable are all available in your PATH . If they are not, you can try the following: ;; Ensure your Emacs environment looks like your user's shell one ( package-require 'exec-path-from-shell ) ( exec-path-from-shell-initialize ) Finally, to enable logging on the client-side, just: ( setq lsp-log-io t ) You can then follow the client logs for the current workspace by doing: M-x lsp-workspace-show-log Tips and Tricks Shortcuts for code lenses and quick actions You can run M-x lsp-avy-lens to show letters next to code lenses. You can then press those letters to trigger the respective action. If your sideline is enabled ( (setq lsp-ui-sideline-enable t) ), you can also use M-x lsp-execute-code-action to trigger quick-fix actions.","title":"Emacs"},{"location":"getting-started/emacs/#emacs","text":"","title":"Emacs"},{"location":"getting-started/emacs/#setup","text":"The official lsp-mode package includes a client for the Erlang Language Server. Here you can find a sample Emacs configuration file which installs and configures all packages required to get all of the Erlang LS features working. Use this configuration file as a starting point for your Erlang LS Emacs configuration. Whenever opening a project for the first time, you will be prompted by emacs-lsp to select the correct project root. In that occasion, you also have the opportunity to blacklist projects. Information about projects is stored in a file pointed by the lsp-session-file variable. Its default location is ~/.emacs.d/.lsp-session-v1 . You may need to prune or amend this file if you change your mind about blacklisting a project or if you erroneously select a project root. For more information about the lsp-session-file and emacs-lsp in general, please refer to the official documentation . Remember that the Erlang Language Server requires Erlang/OTP 21 or higher to run, so ensure that OTP 21+ is available in your PATH . This can be achieved, for example, by using the exec-path-from-shell Emacs package.","title":"Setup"},{"location":"getting-started/emacs/#restarting-the-language-server","text":"You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so: M-x lsp-workspace-restart","title":"Restarting the language server"},{"location":"getting-started/emacs/#troubleshooting","text":"If things do not work as expected, we advise you to start Emacs with only the configuration from the provided sample file, using the following command: emacs -q -l [PATH-TO-ERLANG-LS]/misc/dotemacs This will remove from the equation potential incompatibilities with other packages or configurations that you may have on your workstation and that could conflict with Erlang LS. To be sure that you don't have outdated or incompatible packages installed, you may also want to rename your ~/.emacs.d directory while you are troubleshooting your Erlang LS Emacs setup. Also, ensure that Erlang (i.e. erl , escript and friends) and the erlang_ls executable are all available in your PATH . If they are not, you can try the following: ;; Ensure your Emacs environment looks like your user's shell one ( package-require 'exec-path-from-shell ) ( exec-path-from-shell-initialize ) Finally, to enable logging on the client-side, just: ( setq lsp-log-io t ) You can then follow the client logs for the current workspace by doing: M-x lsp-workspace-show-log","title":"Troubleshooting"},{"location":"getting-started/emacs/#tips-and-tricks","text":"","title":"Tips and Tricks"},{"location":"getting-started/emacs/#shortcuts-for-code-lenses-and-quick-actions","text":"You can run M-x lsp-avy-lens to show letters next to code lenses. You can then press those letters to trigger the respective action. If your sideline is enabled ( (setq lsp-ui-sideline-enable t) ), you can also use M-x lsp-execute-code-action to trigger quick-fix actions.","title":"Shortcuts for code lenses and quick actions"},{"location":"getting-started/intellij/","text":"IntelliJ Setup WARNING : The current version of the IntelliJ LSP plugin (1.6.1) is quite limited, so not all of the Erlang Language Server capabilities are available in IntelliJ. First of all, ensure you have the LSP Support plugin installed. If you don't, you can simply navigate to: Preferences > Plugins > Browse Repositories Search for \"LSP Support\" and install the respective plugin. Restart IntelliJ, then navigate to: Preferences > Languages and Frameworks > Language Server Protocol > Server Definitions There you can instruct IntelliJ on how to start the server. Select Raw Command , set erl;hrl as the extension, then add as the command: /ABSOLUTE/PATH/TO/erlang_ls/_build/default/bin/erlang_ls --transport stdio Ensure you use an absolute path. The plugin does not seem to understand the ~ symbol. For the above command to work, IntelliJ requires the PATH variable to be correctly configured to include Erlang 20+. To circumvent this issues on Mac OS, the best way is to start IntelliJ from the terminal (i.e. via the idea command) and not via Spotlight. To visualize documentation and type specs while hovering a function, ensure the Show quick documentation on mouse move option is enabled in your IntelliJ preferences: Preferences > Editor > General There, you can also set a delay in milliseconds. For more information about how to configure the IntelliJ LSP Client, please refer to the project GitHub page . Troubleshooting In some cases, the IntelliJ LSP client may not be able to connect to the server. In such cases, the first step is to enable logging: Preferences > Languages and Frameworks > Language Server Protocol Check the Log servers communications check-box there. After restarting IntelliJ, you will notice an extra lsp directory created inside your Erlang project. This directory contains the error and output logs, which should give you a hint about what is going on. An alternative source of information is represented by the IntelliJ logs: Help > Show Logs","title":"IntelliJ"},{"location":"getting-started/intellij/#intellij","text":"","title":"IntelliJ"},{"location":"getting-started/intellij/#setup","text":"WARNING : The current version of the IntelliJ LSP plugin (1.6.1) is quite limited, so not all of the Erlang Language Server capabilities are available in IntelliJ. First of all, ensure you have the LSP Support plugin installed. If you don't, you can simply navigate to: Preferences > Plugins > Browse Repositories Search for \"LSP Support\" and install the respective plugin. Restart IntelliJ, then navigate to: Preferences > Languages and Frameworks > Language Server Protocol > Server Definitions There you can instruct IntelliJ on how to start the server. Select Raw Command , set erl;hrl as the extension, then add as the command: /ABSOLUTE/PATH/TO/erlang_ls/_build/default/bin/erlang_ls --transport stdio Ensure you use an absolute path. The plugin does not seem to understand the ~ symbol. For the above command to work, IntelliJ requires the PATH variable to be correctly configured to include Erlang 20+. To circumvent this issues on Mac OS, the best way is to start IntelliJ from the terminal (i.e. via the idea command) and not via Spotlight. To visualize documentation and type specs while hovering a function, ensure the Show quick documentation on mouse move option is enabled in your IntelliJ preferences: Preferences > Editor > General There, you can also set a delay in milliseconds. For more information about how to configure the IntelliJ LSP Client, please refer to the project GitHub page .","title":"Setup"},{"location":"getting-started/intellij/#troubleshooting","text":"In some cases, the IntelliJ LSP client may not be able to connect to the server. In such cases, the first step is to enable logging: Preferences > Languages and Frameworks > Language Server Protocol Check the Log servers communications check-box there. After restarting IntelliJ, you will notice an extra lsp directory created inside your Erlang project. This directory contains the error and output logs, which should give you a hint about what is going on. An alternative source of information is represented by the IntelliJ logs: Help > Show Logs","title":"Troubleshooting"},{"location":"getting-started/overview/","text":"Getting Started The Erlang LS language server works with all text editors and IDEs which adhere to the LSP protocol. The list of supported editors include Emacs , Vim , VS Code , Sublime Text 3 and more. These pages contain all the information needed to configure your favourite text editor or IDE to use Erlang LS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected. Emacs Spacemacs VS Code Sublime Text 3 IntelliJ Vim Theia IDE","title":"Overview"},{"location":"getting-started/overview/#getting-started","text":"The Erlang LS language server works with all text editors and IDEs which adhere to the LSP protocol. The list of supported editors include Emacs , Vim , VS Code , Sublime Text 3 and more. These pages contain all the information needed to configure your favourite text editor or IDE to use Erlang LS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected. Emacs Spacemacs VS Code Sublime Text 3 IntelliJ Vim Theia IDE","title":"Getting Started"},{"location":"getting-started/spacemacs/","text":"Spacemacs Setup The develop branch includes an Erlang layer with support for the Language Server Protocol using Erlang LS as backend. Here you can find information about installation and configuration, as well as supported features. Both, lsp and erlang-mode variables, can be configured when setting up dotspacemacs-configuration-layers , e.g: dotspacemacs-configuration-layers ' ( ;... lsp ( erlang :variables erlang-backend 'lsp erlang-root-dir \"<path to>/otp_22/lib/erlang\" erlang-man-root-dir \"<path to>/otp_22_kred/lib/erlang/man\" erlang-fill-column 100 company-minimum-prefix-length 1 company-idle-delay 0.3 lsp-ui-doc-position 'bottom ) ;... )","title":"Spacemacs"},{"location":"getting-started/spacemacs/#spacemacs","text":"","title":"Spacemacs"},{"location":"getting-started/spacemacs/#setup","text":"The develop branch includes an Erlang layer with support for the Language Server Protocol using Erlang LS as backend. Here you can find information about installation and configuration, as well as supported features. Both, lsp and erlang-mode variables, can be configured when setting up dotspacemacs-configuration-layers , e.g: dotspacemacs-configuration-layers ' ( ;... lsp ( erlang :variables erlang-backend 'lsp erlang-root-dir \"<path to>/otp_22/lib/erlang\" erlang-man-root-dir \"<path to>/otp_22_kred/lib/erlang/man\" erlang-fill-column 100 company-minimum-prefix-length 1 company-idle-delay 0.3 lsp-ui-doc-position 'bottom ) ;... )","title":"Setup"},{"location":"getting-started/sublime3/","text":"Sublime Text 3 Setup Install the Erlang LS Language Server To install Erlang LS: git clone https://github.com/erlang-ls/erlang_ls cd erlang_ls rebar3 escriptize This will create an Erlang escript in: _build/default/bin/erlang_ls Try running Erlang LS with the --version flag to verify everything works as expected: _build/default/bin/erlang_ls --version Ensure erlang_ls is in your PATH . Install the LSP Client for Sublime Text 3 Using the Command Palette from the Tools menu, select Package Control: Install Package and install the LSP package. After that is done, go to: Preferences -> Package Settings -> LSP -> Settings Add an Erlang client by adding the following configuration to the LSP.sublime-settings - User file: { \"clients\": { \"erlang-ls\": { \"command\" : [ \"erlang_ls\", \"--transport\", \"stdio\" ], \"enabled\" : true, \"languageId\": \"erlang\", \"scopes\" : [ \"source.erlang\" ], \"syntaxes\" : [\"Packages/Erlang/Erlang.sublime-syntax\"] } }, // Allow up to 30 secs to `erlang_ls` to respond to `initialize` // (it requires less, but just to be on the safe side) \"initialize_timeout\": 30 } That's it. Open a new Erlang project and enjoy Erlang LS. Troubleshooting Ensure Erlang LS is in your PATH To be able to use Erlang LS, the erlang_ls escript needs to be in your path. Are You a macOS User? If you are a macOS user, you may consider using the following plugin to ensure your PATH is correctly used by Sublime Text 3: https://github.com/int3h/SublimeFixMacPath Enabling logging In case of issues, you can enable extra logging for the LSP package by adding the following configuration to your LSP.sublime-settings - User file: { // Show verbose debug messages in the sublime console. \"log_debug\": true, // Show messages from language servers in the Language Servers output // panel. \"log_server\": true, // Show language server stderr output in the Language Servers output // panel. \"log_stderr\": true, // Show full JSON-RPC requests/responses/notifications in the Language // Servers output panel. \"log_payloads\": true } The Sublime console can be toggled using the Ctrl-` shortcut. The output panel can be toggled from the command palette with the command LSP: Toggle Panel: Language Servers .","title":"Sublime Text 3"},{"location":"getting-started/sublime3/#sublime-text-3","text":"","title":"Sublime Text 3"},{"location":"getting-started/sublime3/#setup","text":"","title":"Setup"},{"location":"getting-started/sublime3/#install-the-erlang-ls-language-server","text":"To install Erlang LS: git clone https://github.com/erlang-ls/erlang_ls cd erlang_ls rebar3 escriptize This will create an Erlang escript in: _build/default/bin/erlang_ls Try running Erlang LS with the --version flag to verify everything works as expected: _build/default/bin/erlang_ls --version Ensure erlang_ls is in your PATH .","title":"Install the Erlang LS Language Server"},{"location":"getting-started/sublime3/#install-the-lsp-client-for-sublime-text-3","text":"Using the Command Palette from the Tools menu, select Package Control: Install Package and install the LSP package. After that is done, go to: Preferences -> Package Settings -> LSP -> Settings Add an Erlang client by adding the following configuration to the LSP.sublime-settings - User file: { \"clients\": { \"erlang-ls\": { \"command\" : [ \"erlang_ls\", \"--transport\", \"stdio\" ], \"enabled\" : true, \"languageId\": \"erlang\", \"scopes\" : [ \"source.erlang\" ], \"syntaxes\" : [\"Packages/Erlang/Erlang.sublime-syntax\"] } }, // Allow up to 30 secs to `erlang_ls` to respond to `initialize` // (it requires less, but just to be on the safe side) \"initialize_timeout\": 30 } That's it. Open a new Erlang project and enjoy Erlang LS.","title":"Install the LSP Client for Sublime Text 3"},{"location":"getting-started/sublime3/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"getting-started/sublime3/#ensure-erlang-ls-is-in-your-path","text":"To be able to use Erlang LS, the erlang_ls escript needs to be in your path. Are You a macOS User? If you are a macOS user, you may consider using the following plugin to ensure your PATH is correctly used by Sublime Text 3: https://github.com/int3h/SublimeFixMacPath","title":"Ensure Erlang LS is in your PATH"},{"location":"getting-started/sublime3/#enabling-logging","text":"In case of issues, you can enable extra logging for the LSP package by adding the following configuration to your LSP.sublime-settings - User file: { // Show verbose debug messages in the sublime console. \"log_debug\": true, // Show messages from language servers in the Language Servers output // panel. \"log_server\": true, // Show language server stderr output in the Language Servers output // panel. \"log_stderr\": true, // Show full JSON-RPC requests/responses/notifications in the Language // Servers output panel. \"log_payloads\": true } The Sublime console can be toggled using the Ctrl-` shortcut. The output panel can be toggled from the command palette with the command LSP: Toggle Panel: Language Servers .","title":"Enabling logging"},{"location":"getting-started/theia/","text":"Theia IDE Setup It is possible to use Erlang LS in Theia IDE by including Erlang/OTP in your running instance and installing the VSCode extension . If you want to give it a try by using GitPod click here . To use this same setup with your Erlang project (hosted in GitHub or Gitlab) you can find the GitPod configuration in .gitpod.yml .","title":"Theia IDE"},{"location":"getting-started/theia/#theia-ide","text":"","title":"Theia IDE"},{"location":"getting-started/theia/#setup","text":"It is possible to use Erlang LS in Theia IDE by including Erlang/OTP in your running instance and installing the VSCode extension . If you want to give it a try by using GitPod click here . To use this same setup with your Erlang project (hosted in GitHub or Gitlab) you can find the GitPod configuration in .gitpod.yml .","title":"Setup"},{"location":"getting-started/vim/","text":"Vim / NeoVim NOTE : Neovim has recently included a native Language Server , though it is not yet available over in many distributed versions (e.g. brew ). Once the native solution is verified to work well, we will update this documentation to reflect the setup. Setup The following instructions should enable Erlang language server integration via the Coc system (an intellisense engine for both Vim and Neovim). Installing Coc with vim-plug For vim-plug users with nodejs >= 10.12 installed, installing the plugin is just: \" Use release branch (Recommended) Plug 'neoclide/coc.nvim' , { 'branch' : 'release' } To make the plugin aware of erlang_ls however, it needs configuration. Coc plugin configuration Coc is configured through coc-settings.json , which can be opened in vim by issuing the command: : CocConfig If erlang_ls is present in your $PATH variable then the following config should suffice: { \"languageserver\": { \"erlang\": { \"command\": \"erlang_ls\", \"filetypes\": [\"erlang\"] } } } When vim starts editing a file of filetype erlang , if the erlang_ls server can be started and connected to, you should see something like the following message from Coc: [coc.nvim] Erlang LS ( in erlang_ls ), version: X.Y.Z + build.REF For suggestions on configuring Coc and possible key-bindings see its example configuration documentation .","title":"Vim"},{"location":"getting-started/vim/#vim-neovim","text":"NOTE : Neovim has recently included a native Language Server , though it is not yet available over in many distributed versions (e.g. brew ). Once the native solution is verified to work well, we will update this documentation to reflect the setup.","title":"Vim / NeoVim"},{"location":"getting-started/vim/#setup","text":"The following instructions should enable Erlang language server integration via the Coc system (an intellisense engine for both Vim and Neovim).","title":"Setup"},{"location":"getting-started/vim/#installing-coc-with-vim-plug","text":"For vim-plug users with nodejs >= 10.12 installed, installing the plugin is just: \" Use release branch (Recommended) Plug 'neoclide/coc.nvim' , { 'branch' : 'release' } To make the plugin aware of erlang_ls however, it needs configuration.","title":"Installing Coc with vim-plug"},{"location":"getting-started/vim/#coc-plugin-configuration","text":"Coc is configured through coc-settings.json , which can be opened in vim by issuing the command: : CocConfig If erlang_ls is present in your $PATH variable then the following config should suffice: { \"languageserver\": { \"erlang\": { \"command\": \"erlang_ls\", \"filetypes\": [\"erlang\"] } } } When vim starts editing a file of filetype erlang , if the erlang_ls server can be started and connected to, you should see something like the following message from Coc: [coc.nvim] Erlang LS ( in erlang_ls ), version: X.Y.Z + build.REF For suggestions on configuring Coc and possible key-bindings see its example configuration documentation .","title":"Coc plugin configuration"},{"location":"getting-started/vscode/","text":"VSCode Setup The Erlang Language Server is available in VSCode via a dedicated extension . To try it out, simply open VSCode and install the extension via the Marketplace: Preferences > Extensions Look for the erlang-ls extension and install it. That's it. Remember that the Erlang Language Server requires Erlang/OTP 21 or higher to run, so ensure that OTP 21+ is available in your PATH . Restarting the language server You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so: View -> Command Palette... -> Developer: Reload Window On Mac OS you can use the Cmd+Shift+P shortcut to quickly access the command palette.","title":"VSCode"},{"location":"getting-started/vscode/#vscode","text":"","title":"VSCode"},{"location":"getting-started/vscode/#setup","text":"The Erlang Language Server is available in VSCode via a dedicated extension . To try it out, simply open VSCode and install the extension via the Marketplace: Preferences > Extensions Look for the erlang-ls extension and install it. That's it. Remember that the Erlang Language Server requires Erlang/OTP 21 or higher to run, so ensure that OTP 21+ is available in your PATH .","title":"Setup"},{"location":"getting-started/vscode/#restarting-the-language-server","text":"You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so: View -> Command Palette... -> Developer: Reload Window On Mac OS you can use the Cmd+Shift+P shortcut to quickly access the command palette.","title":"Restarting the language server"}]}